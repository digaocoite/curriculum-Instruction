<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>The Biliteracy Quest</title>
  <style>
    :root{
      --mizzou-gold:#F1B82D;
      --mizzou-black:#000000;
      --ink:#111;
      --paper:#ffffff;
      --soft:#f6f6f8;
      --soft2:#f1f3f7;
      --muted:#5b616e;
      --line:#e6e7eb;
      --success:#0b7a3b;
      --accent:#1b1b1b;
      --shadow: 0 12px 30px rgba(0,0,0,.10);
      --shadow2: 0 10px 22px rgba(0,0,0,.08);
      --radius:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      background:
        radial-gradient(1200px 700px at 10% 0%, rgba(241,184,45,.22), transparent 60%),
        radial-gradient(900px 600px at 90% 10%, rgba(0,0,0,.10), transparent 55%),
        linear-gradient(180deg, #fff 0%, #fbfbfd 60%, #fff 100%);
      min-height:100vh;
    }
    .wrap{max-width:1180px; margin:0 auto; padding:22px 18px 40px;}
    .topbar{
      display:flex; gap:16px; align-items:stretch; justify-content:space-between;
      padding:16px; border-radius:var(--radius);
      background:linear-gradient(135deg, rgba(0,0,0,.95), rgba(0,0,0,.86));
      color:#fff; box-shadow:var(--shadow);
      border:1px solid rgba(241,184,45,.35);
    }
    .brand{display:flex; flex-direction:column; gap:6px;}
    .brand h1{
      margin:0; font-size:20px; letter-spacing:.2px;
      display:flex; gap:10px; align-items:center; line-height:1.15;
    }
    .badgeLogo{
      width:34px; height:34px; border-radius:12px;
      background:conic-gradient(from 180deg, var(--mizzou-gold), #ffd86a, var(--mizzou-gold));
      display:grid; place-items:center; color:#000; font-weight:900;
      box-shadow:0 10px 20px rgba(241,184,45,.22);
    }
    .brand p{margin:0; color:rgba(255,255,255,.78); font-size:13px; max-width:560px;}
    .actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:#fff; padding:10px 12px; border-radius:14px;
      font-weight:650; font-size:13px; cursor:pointer;
      display:inline-flex; align-items:center; gap:10px;
      transition:transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    .btn:hover{background:rgba(255,255,255,.12)}
    .btn:active{transform:translateY(1px)}
    .btnGold{
      background:linear-gradient(180deg, var(--mizzou-gold), #e9ab10);
      color:#111; border-color:rgba(0,0,0,.12);
    }
    .btnGold:hover{background:linear-gradient(180deg, #ffd35f, var(--mizzou-gold))}
    .btnGhost{background:transparent}
    .grid{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap:16px;
      margin-top:16px;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
      .actions{justify-content:flex-start}
    }
    .card{
      background:var(--paper);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow2);
      overflow:hidden;
    }
    .cardHeader{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, #fff, var(--soft));
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .cardHeader h2{margin:0; font-size:15px;}
    .cardBody{padding:16px;}
    .playerPanel{display:flex; flex-direction:column; gap:10px;}
    .statRow{display:flex; gap:10px; flex-wrap:wrap;}
    .stat{
      flex:1;
      min-width:140px;
      background:linear-gradient(180deg, #fff, var(--soft));
      border:1px solid var(--line);
      border-radius:16px;
      padding:10px 12px;
    }
    .stat .k{font-size:11px; color:var(--muted); margin-bottom:6px;}
    .stat .v{font-size:16px; font-weight:800;}
    .progressWrap{
      margin-top:2px;
      height:10px; background:var(--soft2); border-radius:999px; overflow:hidden;
      border:1px solid var(--line);
    }
    .progressBar{
      height:100%;
      width:0%;
      background:linear-gradient(90deg, var(--mizzou-gold), #ffd86a);
      transition:width .35s ease;
    }
    .tiny{font-size:12px; color:var(--muted); margin:0;}

    .questMap{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
      padding:14px 16px;
      background:linear-gradient(180deg, #fff, var(--soft));
      border-bottom:1px solid var(--line);
    }
    @media (max-width: 680px){
      .questMap{grid-template-columns:1fr; }
    }
    .checkpoint{
      border-radius:16px;
      border:1px solid var(--line);
      background:#fff;
      padding:10px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      cursor:pointer;
      transition:transform .08s ease, border-color .2s ease, box-shadow .2s ease;
    }
    .checkpoint:hover{border-color:#d6d7dc; box-shadow:0 10px 20px rgba(0,0,0,.06)}
    .checkpoint:active{transform:translateY(1px)}
    .checkpoint .left{display:flex; align-items:center; gap:10px;}
    .bubble{
      width:28px; height:28px; border-radius:12px;
      display:grid; place-items:center;
      background:rgba(241,184,45,.18);
      border:1px solid rgba(241,184,45,.35);
      font-weight:900;
    }
    .checkpoint.done .bubble{background:rgba(11,122,59,.14); border-color:rgba(11,122,59,.35)}
    .checkpoint.active{border-color:rgba(241,184,45,.55)}
    .checkpoint small{color:var(--muted)}
    .checkMark{font-weight:900; color:var(--success); display:none;}
    .checkpoint.done .checkMark{display:inline}

    .missions{
      display:grid;
      grid-template-columns: repeat(2, 1fr);
      gap:12px;
    }
    @media (max-width: 680px){
      .missions{grid-template-columns:1fr;}
    }
    .mission{
      border-radius:18px;
      border:1px solid var(--line);
      background:linear-gradient(180deg,#fff,var(--soft));
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:230px;
    }
    .missionTop{
      padding:12px 12px 10px;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
    }
    .missionTitle{margin:0; font-size:14px; font-weight:900;}
    .tagRow{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    .tag{
      font-size:11px; padding:6px 8px; border-radius:999px;
      background:rgba(0,0,0,.06); color:#222; border:1px solid rgba(0,0,0,.07);
    }
    .tagGold{background:rgba(241,184,45,.22); border-color:rgba(241,184,45,.40)}
    .tagDark{background:rgba(0,0,0,.08)}
    .tagGreen{background:rgba(11,122,59,.12); border-color:rgba(11,122,59,.24)}
    .missionArt{
      height:110px;
      margin:0 12px 10px;
      border-radius:16px;
      background:
        radial-gradient(180px 120px at 20% 35%, rgba(241,184,45,.55), transparent 60%),
        radial-gradient(220px 140px at 80% 10%, rgba(0,0,0,.18), transparent 65%),
        linear-gradient(135deg, rgba(0,0,0,.92), rgba(0,0,0,.72));
      border:1px solid rgba(241,184,45,.25);
      position:relative;
      overflow:hidden;
    }
    .missionArt .emoji{
      position:absolute; inset:auto 14px 12px auto;
      font-size:34px;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
    }
    .missionArt .sigil{
      position:absolute; left:14px; top:14px;
      width:42px; height:42px; border-radius:16px;
      background:conic-gradient(from 180deg, var(--mizzou-gold), #ffd86a, var(--mizzou-gold));
      display:grid; place-items:center; font-weight:1000; color:#000;
      box-shadow:0 12px 26px rgba(241,184,45,.20);
    }
    .missionArt .caption{
      position:absolute; left:14px; bottom:14px; right:14px;
      color:rgba(255,255,255,.88);
      font-size:12px;
      line-height:1.3;
    }
    .missionBottom{
      padding:0 12px 12px;
      margin-top:auto;
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .difficulty{font-size:12px; color:var(--muted); display:flex; align-items:center; gap:8px;}
    .stars{letter-spacing:2px; color:var(--mizzou-gold); text-shadow:0 8px 14px rgba(241,184,45,.15);}

    .panel{
      border:1px solid var(--line);
      border-radius:18px;
      background:#fff;
      overflow:hidden;
    }
    .panelHeader{
      padding:14px 16px;
      border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, #fff, var(--soft));
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    .panelHeader h3{margin:0; font-size:14px;}
    .panelBody{padding:16px;}
    .scene{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
      margin-bottom:14px;
    }
    @media (max-width: 860px){
      .scene{grid-template-columns:1fr;}
    }
    .sceneBox{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background:linear-gradient(180deg,#fff,var(--soft));
    }
    .sceneBox h4{margin:0 0 8px; font-size:13px;}
    .sceneBox p{margin:0; color:#222; line-height:1.45; font-size:13px;}
    .artifact{
      border:1px solid rgba(241,184,45,.35);
      border-radius:16px;
      background:
        radial-gradient(160px 120px at 15% 20%, rgba(241,184,45,.35), transparent 65%),
        linear-gradient(135deg, #111, #2a2a2a);
      color:#fff;
      padding:12px;
      position:relative;
      min-height:130px;
      overflow:hidden;
    }
    .artifact .label{
      display:inline-flex; align-items:center; gap:8px;
      font-size:11px;
      padding:6px 8px;
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      background:rgba(255,255,255,.08);
    }
    .artifact .paper{
      margin-top:10px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16);
      border-radius:14px;
      padding:10px;
      font-size:12px;
      line-height:1.35;
      color:rgba(255,255,255,.90);
      white-space:pre-wrap;
    }

    .choices{
      display:grid;
      grid-template-columns:repeat(3,1fr);
      gap:10px;
      margin:12px 0 10px;
    }
    @media (max-width: 860px){
      .choices{grid-template-columns:1fr;}
    }
    .choice{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background:#fff;
      cursor:pointer;
      transition:transform .08s ease, border-color .2s ease, box-shadow .2s ease, background .2s ease;
      display:flex; flex-direction:column; gap:10px;
      min-height:110px;
    }
    .choice:hover{border-color:rgba(241,184,45,.55); box-shadow:0 12px 20px rgba(0,0,0,.06); background:linear-gradient(180deg,#fff,rgba(241,184,45,.08))}
    .choice:active{transform:translateY(1px)}
    .choice .cap{font-weight:900; font-size:12px; display:flex; justify-content:space-between; gap:10px;}
    .choice .cap span{color:var(--muted); font-weight:800}
    .choice p{margin:0; font-size:12.5px; color:#222; line-height:1.35;}

    .resultGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media (max-width: 860px){
      .resultGrid{grid-template-columns:1fr;}
    }
    .result{
      border-radius:16px;
      border:1px solid var(--line);
      padding:12px;
      background:linear-gradient(180deg,#fff,var(--soft));
    }
    .result h4{margin:0 0 6px; font-size:12.5px}
    .result p{margin:0; color:#222; font-size:12.5px; line-height:1.4}
    .result .hint{margin-top:8px; color:var(--muted); font-size:12px}

    .lensRow{display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; align-items:center;}
    .lensBtn{
      border-radius:999px;
      padding:8px 10px;
      border:1px solid rgba(241,184,45,.40);
      background:rgba(241,184,45,.18);
      cursor:pointer;
      font-weight:850;
      font-size:12px;
      display:inline-flex; gap:8px; align-items:center;
      transition:transform .08s ease, background .2s ease;
    }
    .lensBtn:hover{background:rgba(241,184,45,.25)}
    .lensBtn:active{transform:translateY(1px)}
    .lensPop{
      margin-top:10px;
      border:1px solid rgba(241,184,45,.40);
      background:linear-gradient(180deg, rgba(241,184,45,.14), rgba(241,184,45,.06));
      border-radius:16px;
      padding:12px;
      display:none;
    }
    .lensPop strong{display:block; margin-bottom:6px}
    .lensPop ul{margin:0; padding-left:18px; color:#222; font-size:12.5px; line-height:1.45}
    .lensPop li{margin:4px 0}

    .inputBox{
      margin-top:10px;
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      background:#fff;
    }
    textarea{
      width:100%;
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
      resize:vertical;
      min-height:90px;
      font-size:13px;
      line-height:1.4;
      outline:none;
    }
    textarea:focus{border-color:rgba(241,184,45,.60); box-shadow:0 0 0 4px rgba(241,184,45,.18)}
    .row{
      display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap;
      margin-top:10px;
    }
    .note{font-size:12px; color:var(--muted); margin:0;}
    .pill{
      border-radius:999px; padding:7px 10px;
      border:1px solid var(--line);
      background:linear-gradient(180deg,#fff,var(--soft));
      font-size:12px;
      display:inline-flex; gap:8px; align-items:center;
    }

    .spellbook{
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:12px;
    }
    @media (max-width: 680px){
      .spellbook{grid-template-columns:1fr;}
    }
    .spell{
      border:1px solid var(--line);
      border-radius:18px;
      background:#fff;
      overflow:hidden;
    }
    .spellTop{
      padding:12px;
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px;
      background:linear-gradient(180deg,#fff,var(--soft));
      border-bottom:1px solid var(--line);
    }
    .spellTop h4{margin:0; font-size:13px}
    .spellTop small{color:var(--muted)}
    .spellBody{padding:12px; display:none;}
    .spellBody p{margin:0; color:#222; font-size:12.5px; line-height:1.45}
    .spellBody ul{margin:10px 0 0; padding-left:18px; font-size:12.5px; line-height:1.45}
    .spellBody li{margin:4px 0}
    .spellActions{margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;}
    .miniBtn{
      padding:8px 10px;
      border-radius:14px;
      border:1px solid var(--line);
      background:linear-gradient(180deg,#fff,var(--soft));
      cursor:pointer;
      font-weight:800;
      font-size:12px;
    }
    .miniBtn:hover{border-color:rgba(241,184,45,.55)}
    .miniBtnGold{
      border-color:rgba(241,184,45,.55);
      background:linear-gradient(180deg, rgba(241,184,45,.35), rgba(241,184,45,.18));
    }

    .log{
      border-top:1px solid var(--line);
      padding:12px 16px 16px;
      background:linear-gradient(180deg,#fff,var(--soft));
    }
    .log pre{
      margin:0;
      white-space:pre-wrap;
      word-break:break-word;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size:12px;
      background:#fff;
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
      line-height:1.45;
    }
    .toast{
      position:fixed;
      bottom:18px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(0,0,0,.88);
      color:#fff;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(241,184,45,.35);
      box-shadow:var(--shadow);
      display:none;
      z-index:99;
      font-size:13px;
    }
    .canvasWrap{
      margin-top:12px;
      border:1px solid var(--line);
      border-radius:18px;
      background:linear-gradient(180deg,#fff,var(--soft));
      padding:12px;
      overflow:hidden;
    }
    canvas.postCanvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:16px;
      border:1px solid rgba(0,0,0,.10);
      background:#0b0b0d;
    }
    .canvasActions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      align-items:center;
      justify-content:space-between;
    }
    .helpRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:10px;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size:11px;
      border:1px solid var(--line);
      background:linear-gradient(180deg,#fff,var(--soft));
      border-radius:10px;
      padding:4px 8px;
      color:#111;
    }

    /* Game feel */
    .choice{
      transform:translateY(0);
    }
    .choice.selected{
      border-color:rgba(241,184,45,.75);
      box-shadow:0 18px 28px rgba(0,0,0,.10);
      background:linear-gradient(180deg,#fff,rgba(241,184,45,.10));
    }
    .choice.selected .cap span{color:#111}
    @keyframes pop {
      0%{transform:scale(.98)}
      55%{transform:scale(1.02)}
      100%{transform:scale(1)}
    }
    .pop{animation:pop .22s ease-out}

    #confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:120;
      overflow:hidden;
    }
    .confettiBit{
      position:absolute;
      width:10px; height:14px;
      border-radius:4px;
      opacity:.95;
      transform:translateY(-20px) rotate(0deg);
      animation: confettiFall 900ms ease-in forwards;
      box-shadow:0 8px 16px rgba(0,0,0,.18);
    }
    @keyframes confettiFall{
      to{ transform:translateY(110vh) rotate(480deg); opacity:0.9; }
    }

    /* Reduced motion toggle */
    body.reducedMotion *{
      animation:none !important;
      transition:none !important;
      scroll-behavior:auto !important;
    }
    .hidden{display:none!important}
    .divider{height:1px; background:var(--line); margin:12px 0}
    .footerNote{
      margin-top:16px;
      color:var(--muted);
      font-size:12px;
      line-height:1.45;
      padding:12px 14px;
      border:1px solid var(--line);
      border-radius:18px;
      background:linear-gradient(180deg,#fff,var(--soft));
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <h1>
          <span class="badgeLogo">M</span>
          The Biliteracy Quest
        </h1>
        <p>
          Choose a mission, make decisions, and generate a Decision Path Scroll you can paste into Canvas.
        </p>
      </div>

      <div class="actions">
        <button type="button" class="btn btnGold" id="btnStart">Mission Hub</button>
        <button type="button" class="btn" id="btnSpellbook">Theory Spellbook</button>
        <button type="button" class="btn" id="btnDaily">Daily Challenge</button>
        <button type="button" class="btn" id="btnDifficulty">Mode: Normal</button>
        <button type="button" class="btn" id="btnSound">Sound: Off</button>
        <button type="button" class="btn" id="btnMotion">Motion: On</button>
        <button type="button" class="btn btnGhost" id="btnReset">Reset</button>
      </div>
    </div>

    <div id="confetti" aria-hidden="true"></div>

    <div class="grid">
      <div class="card" id="cardMain">
        <div class="questMap" id="questMap">
          <div class="checkpoint active" data-step="0">
            <div class="left">
              <div class="bubble">1</div>
              <div>
                <div><b>Choose Mission</b></div>
                <small>Pick your challenge</small>
              </div>
            </div>
            <div class="checkMark">‚úì</div>
          </div>
          <div class="checkpoint" data-step="1">
            <div class="left">
              <div class="bubble">2</div>
              <div>
                <div><b>Face Scenario</b></div>
                <small>Decide, see outcomes</small>
              </div>
            </div>
            <div class="checkMark">‚úì</div>
          </div>
          <div class="checkpoint" data-step="2">
            <div class="left">
              <div class="bubble">3</div>
              <div>
                <div><b>Consult Theory</b></div>
                <small>Apply a lens</small>
              </div>
            </div>
            <div class="checkMark">‚úì</div>
          </div>
          <div class="checkpoint" data-step="3">
            <div class="left">
              <div class="bubble">4</div>
              <div>
                <div><b>Build Output</b></div>
                <small>Decision scroll</small>
              </div>
            </div>
            <div class="checkMark">‚úì</div>
          </div>
          <div class="checkpoint" data-step="4">
            <div class="left">
              <div class="bubble">5</div>
              <div>
                <div><b>Submit</b></div>
                <small>Copy into Canvas</small>
              </div>
            </div>
            <div class="checkMark">‚úì</div>
          </div>
        </div>

        <div class="cardBody" id="mainBody">
          <div id="screenMissions">
            <h2 style="margin:0 0 10px;">Mission Hub</h2>
            <p class="tiny" style="margin:0 0 14px;">
              Pick one mission. You‚Äôll complete 3 rounds. Save at least one justification to earn XP.
            </p>
            <div class="missions" id="missions"></div>
            <div class="footerNote">
              Tip: The best answers explain tradeoffs and connect decisions to theory, not ‚Äúperfect‚Äù choices.
            </div>
          </div>

          <div id="screenScenario" class="hidden">
            <div class="panel">
              <div class="panelHeader">
                <h3 id="scenarioTitle">Scenario</h3>
                <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
                  <div class="pill" id="roundPill">Round 1 of 3</div>
                  <div class="pill" id="runTimerPill">‚è± 00:00</div>
                  <div class="pill" id="streakPill">Streak 0</div>
                  <div class="pill" id="roundMapPill">‚óâ ‚óã ‚óã</div>
                </div>
              </div>

              <div class="panelBody">
                <div class="scene">
                  <div class="sceneBox">
                    <h4>Story Scene</h4>
                    <p id="scenarioScene"></p>
                  </div>
                  <div class="artifact">
                    <div class="label">Classroom artifact</div>
                    <div class="paper" id="scenarioArtifact"></div>
                  </div>
                </div>

                <div>
                  <div style="display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
                    <div>
                      <b id="decisionPrompt">Decision Point</b>
                      <div class="tiny" id="decisionHint">Choose one action</div>
                    </div>
                    <div class="pill">Earn XP by saving a justification</div>
                  </div>

                  <div class="choices" id="choices"></div>

                  <div id="resultArea" class="hidden">
                    <div class="resultGrid">
                      <div class="result">
                        <h4>Outcome</h4>
                        <p id="outcomeText"></p>
                        <div class="hint" id="tradeoffText"></div>
                      </div>
                      <div class="result">
                        <h4>Theory Lens Prompt</h4>
                        <p id="lensPrompt"></p>
                        <div class="lensRow">
                          <button type="button" class="lensBtn" id="btnShowLens">Open Lens Hints</button>
                          <button type="button" class="lensBtn" id="btnCoach">Ask Coach</button>
                          <button type="button" class="lensBtn" id="btnNext">Next Round</button>
                        </div>
                        <div class="lensPop" id="lensPop"></div>
                        <div class="lensPop" id="coachPop"></div>
                      </div>
                    </div>

                    <div class="inputBox">
                      <b>Justify your choice</b>
                      <p class="note">Write 3 to 6 sentences. Mention at least one author or course idea.</p>
                      <textarea id="justification" placeholder="Example: I chose option B because it supports oral rehearsal before writing, which aligns with Gibbons. It also increases access by creating structured participation pathways, which connects to Hornberger. A risk is time, so I would keep the oral step brief and use a visual organizer to bridge into writing."></textarea>
                      <div class="row">
                        <button type="button" class="btn btnGold" id="btnSaveJustification">Save justification and earn XP</button>
                        <span class="note" id="justificationStatus">Not saved yet</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div class="log">
                <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
                  <b>Decision Path Scroll</b>
                  <div style="display:flex; gap:10px; flex-wrap:wrap;">
                    <button type="button" class="miniBtn" id="btnCopyLog">Copy scroll</button>
                    <button type="button" class="miniBtn" id="btnRenderPostInline">Update Canvas post image</button>
                    <button type="button" class="miniBtn miniBtnGold" id="btnFinish">Finish mission</button>
                  </div>
                </div>
                <div class="divider"></div>
                <pre id="logText">Pick a mission to begin.</pre>
              </div>
            </div>
          </div>

          <div id="screenSubmit" class="hidden">
            <div class="panel">
              <div class="panelHeader">
                <h3>Quest Complete</h3>
                <div class="pill" id="badgeSummary">Badges 0</div>
              </div>
              <div class="panelBody">
                <div class="sceneBox">
                  <h4>What to submit in Canvas</h4>
                  <ul style="margin:0; padding-left:18px; line-height:1.55; font-size:13px;">
                    <li>Paste your Decision Path Scroll</li>
                    <li>Paste one justification paragraph you wrote</li>
                    <li>Add 2 course citations or references to authors you used</li>
                    <li>Brief reflection: what you would do differently next time, and why</li>
                  </ul>
                </div>

                <div style="margin-top:12px;" class="sceneBox">
                  <h4>Copy everything</h4>
                  <p class="tiny" style="margin:0 0 10px;">This copy includes your scroll and any saved justification text.</p>
                  <button type="button" class="btn btnGold" id="btnCopyAll">Copy for Canvas</button>
                </div>

                <div style="margin-top:12px;" class="sceneBox">
                  <h4>Scoreboard</h4>
                  <div id="scoreboard" class="tiny" style="line-height:1.55;"></div>
                  <div class="row">
                    <button type="button" class="miniBtn miniBtnGold" id="btnReplayMission">Replay this mission</button>
                    <span class="note" id="rankNote">‚Äî</span>
                  </div>
                </div>

                <div style="margin-top:12px;" class="sceneBox">
                  <h4>Replay code (share / load exact path)</h4>
                  <p class="tiny" style="margin:0 0 10px;">Share this code or scan the QR in the image. Loading a replay shows the path without changing your XP.</p>
                  <textarea id="replayCode" placeholder="Replay code will appear here..." style="min-height:70px;"></textarea>
                  <div class="row">
                    <button type="button" class="miniBtn" id="btnCopyReplayCode">Copy code</button>
                    <button type="button" class="miniBtn" id="btnLoadReplayCode">Load code</button>
                    <button type="button" class="miniBtn" id="btnClearReplayView">Exit replay view</button>
                  </div>
                </div>

                <div style="margin-top:12px;" class="sceneBox">
                  <h4>Compare two runs</h4>
                  <p class="tiny" style="margin:0 0 10px;">Paste two replay codes to generate a side-by-side comparison image for Canvas.</p>
                  <div class="resultGrid">
                    <div>
                      <b class="tiny">Run A</b>
                      <textarea id="compareCodeA" placeholder="BQ1:..." style="min-height:70px;"></textarea>
                    </div>
                    <div>
                      <b class="tiny">Run B</b>
                      <textarea id="compareCodeB" placeholder="BQ1:..." style="min-height:70px;"></textarea>
                    </div>
                  </div>
                  <div class="row">
                    <button type="button" class="miniBtn miniBtnGold" id="btnCompareRuns">Compare</button>
                    <button type="button" class="miniBtn" id="btnSwapRuns">Swap A/B</button>
                    <span class="note" id="compareStatus">‚Äî</span>
                  </div>
                </div>

                <div class="canvasWrap">
                  <h4 style="margin:0 0 6px;">Canvas Post Image (your exact path)</h4>
                  <p class="tiny" style="margin:0 0 10px;">
                    This generates an image version of your run (mission, choices, outcomes, XP, badges). You can copy it or download it, then add it to a Canvas post.
                  </p>
                  <div class="row" style="margin-top:0;">
                    <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                      <span class="pill">View</span>
                      <button type="button" class="miniBtn miniBtnGold" id="btnViewTimeline">Timeline</button>
                      <button type="button" class="miniBtn" id="btnViewDiagram">Diagram</button>
                      <button type="button" class="miniBtn" id="btnViewCompare">Compare</button>
                    </div>
                    <span class="note" id="postViewNote">Timeline view</span>
                  </div>
                  <canvas id="postCanvas" class="postCanvas" width="1200" height="675" aria-label="Canvas post image preview"></canvas>
                  <div class="canvasActions">
                    <div style="display:flex; gap:10px; flex-wrap:wrap;">
                      <button type="button" class="btn btnGold" id="btnCopyPostImage">Copy image</button>
                      <button type="button" class="btn" id="btnDownloadPostImage">Download PNG</button>
                      <button type="button" class="btn btnGhost" id="btnReRenderPost">Re-render</button>
                    </div>
                    <span class="note" id="postStatus">Ready</span>
                  </div>
                  <div class="helpRow">
                    <span class="pill"><span class="kbd">Tip</span> If ‚ÄúCopy image‚Äù is blocked, use ‚ÄúDownload PNG‚Äù and upload in Canvas.</span>
                    <span class="pill"><span class="kbd">Also</span> The text scroll is still best for accessibility.</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div id="screenSpellbook" class="hidden">
            <div class="panel">
              <div class="panelHeader">
                <h3>Theory Spellbook</h3>
                <div class="pill">Click a card to open</div>
              </div>
              <div class="panelBody">
                <div class="spellbook" id="spellbook"></div>
                <div class="footerNote">
                  Use these prompts to strengthen your justification. Focus on ‚Äúwhy this supports learning‚Äù and ‚Äúwho gains access.‚Äù
                </div>
              </div>
            </div>
          </div>

        </div>
      </div>

      <div class="card">
        <div class="cardHeader">
          <h2>Player Panel</h2>
          <span class="pill" id="levelPill">Level 1</span>
        </div>
        <div class="cardBody">
          <div class="playerPanel">
            <div class="statRow">
              <div class="stat">
                <div class="k">XP</div>
                <div class="v" id="xpVal">0</div>
              </div>
              <div class="stat">
                <div class="k">Badges</div>
                <div class="v" id="badgeVal">0</div>
              </div>
            </div>

            <div class="stat">
              <div class="k">Quest progress</div>
              <div class="progressWrap"><div class="progressBar" id="progressBar"></div></div>
              <p class="tiny" id="progressText" style="margin-top:8px;">Choose a mission to begin.</p>
            </div>

            <div class="stat">
              <div class="k">Unlocked badges</div>
              <div id="badgesList" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
              <p class="tiny" style="margin-top:8px;">Badges unlock when you finish missions and connect decisions to theory.</p>
            </div>

            <div class="stat">
              <div class="k">Run resources & goals</div>
              <div id="resourcesRow" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
              <p class="tiny" id="goalsText" style="margin-top:8px;">Pick a mission to see its goals.</p>
            </div>

            <div class="stat">
              <div class="k">Perks & inventory</div>
              <div id="perksList" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
              <div class="divider"></div>
              <div id="inventoryList" style="display:flex; flex-wrap:wrap; gap:8px;"></div>
              <p class="tiny" style="margin-top:8px;">Perks unlock by leveling up. Artifacts drop on mission completion.</p>
            </div>

            <div class="stat">
              <div class="k">Run history</div>
              <div id="runHistory" style="display:flex; flex-direction:column; gap:8px;"></div>
              <div class="row">
                <button type="button" class="miniBtn" id="btnClearHistory">Clear history</button>
                <span class="tiny">Stored locally in your browser.</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast">Copied</div>

  <script src="vendor/qrcode.js"></script>
  <script>
    const STATE = {
      step: 0, xp: 0, badges: [],
      missionId: null, round: 0,
      decisionLog: [], savedJustifications: [], appliedSpells: [],
      runStartedAtMs: null,
      runEndedAtMs: null,
      streak: 0,
      runId: null,
      runSeed: null,
      dailySeed: null,
      soundOn: false,
      motionOn: true,
      dailyMode: false,
      difficulty: "normal", // "normal" | "support" | "hard"

      // Meta-game
      artifacts: [],

      // Run resources (per mission)
      timeTokens: 0,
      supportTokens: 0,
      streakShieldUsed: false,
      lensUsedRounds: [],
      runRank: null,
      runXpStart: 0,
      hintTokens: 0,
      hintUsedRounds: [],
      hintLog: [],
      timeTokensStart: 0,
      supportTokensStart: 0,
      hintTokensStart: 0,

      // Score breakdown (per mission)
      score: {
        base: 0,
        theory: 0,
        streak: 0,
        spells: 0,
        time: 0
      },

      // Export view
      postView: "timeline" // "timeline" | "diagram" | "compare"
    };

    const SPELLS = [
      {
        id:"gibbons",
        title:"Gibbons: Scaffold Spell",
        subtitle:"Oral to written progression",
        body:[
          "Sequence supports: oral rehearsal, visual organization, then structured writing.",
          "Model, jointly construct, then release responsibility."
        ],
        prompts:[
          "How does your move build meaning before form?",
          "What scaffold makes academic language doable?",
          "How will you fade the scaffold over time?"
        ]
      },
      {
        id:"hornberger",
        title:"Hornberger: Access Charm",
        subtitle:"Identity, access, participation",
        body:[
          "Design multiple entry points for participation.",
          "Value linguistic resources and protect student voice."
        ],
        prompts:[
          "Who gains access with this choice? Who might still be excluded?",
          "How does the choice affirm multilingual identity and voice?",
          "What participation structure makes this equitable?"
        ]
      },
      {
        id:"multimodal",
        title:"Multimodality Mixer",
        subtitle:"Modes reinforce meaning",
        body:[
          "Pair oral, visual, and written modes to reduce cognitive load.",
          "Use visuals to externalize thinking (organizers, annotation, diagrams)."
        ],
        prompts:[
          "What visual element makes the next step clearer?",
          "How do modes connect rather than compete?",
          "What is the simplest multimodal combo that improves understanding?"
        ]
      },
      {
        id:"academic",
        title:"Academic Language Lens",
        subtitle:"Everyday to disciplinary",
        body:[
          "Teach language features as resources for meaning, not rules only.",
          "Connect vocabulary to function: explain, argue, compare, justify."
        ],
        prompts:[
          "Which feature supports clarity and evidence here?",
          "How will you keep student voice while increasing formality?",
          "What scaffold supports transfer to new tasks?"
        ]
      }
    ];

    const PERKS = [
      {
        id:"streakShield",
        title:"Streak Shield",
        minLevel:2,
        blurb:"Once per mission, advancing without saving won‚Äôt break your streak (spends 1 Time Token)."
      },
      {
        id:"scaffoldBoost",
        title:"Scaffold Boost",
        minLevel:3,
        blurb:"+10 XP when your justification includes a theory keyword (Gibbons/Hornberger/etc.)."
      },
      {
        id:"timeBank",
        title:"Time Banker",
        minLevel:4,
        blurb:"Start each mission with +1 Time Token."
      },
      {
        id:"supportSage",
        title:"Support Sage",
        minLevel:5,
        blurb:"Start each mission with +1 Support Token."
      }
    ];

    // 4 playable missions, each with 3 rounds
    const MISSIONS = [
      {
        id: "bridge",
        title: "The Oral to Writing Bridge",
        emoji: "üåâ", sigil: "OW", difficulty: 2,
        tags: ["Gibbons","Scaffolding","Writing"],
        blurb: "Students speak well but struggle to write. Build a bridge from talk to text.",
        scenarioTitle: "Mission: The Oral to Writing Bridge",
        goals: { access: 55, rigor: 45, voice: 40, timeSec: 240 },
        artifactDrop: "Sentence-Frame Sigil",
        rounds: [
          {
            scene:"A glowing sign reads: Academic Paragraph Due. Students have strong ideas in discussion, but writing is short and vague. You have 45 minutes.",
            artifact:"Student line: ‚ÄúI like the university because is big. It is good.‚Äù\nTeacher note: Talk is richer than drafts.",
            prompt:"How do you start this lesson?",
            hint:"Pick a first move that builds meaning before drafting",
            lensHints:[
              "Gibbons: build meaning through talk before demanding written form.",
              "Hornberger: participation pathways and entry points matter.",
              "Ask: who benefits, who might be left out?"
            ],
            choices:[
              {label:"A",title:"Start writing immediately",text:"Draft right away with minimal scaffolding.",
               outcome:"Some write quickly, but many freeze or produce shallow sentences.",
               tradeoff:"Benefit: saves time. Risk: low access for students who need rehearsal or visuals.",
               lensPrompt:"How does this impact access and the shift from oral to written language?"},
              {label:"B",title:"Structured oral rehearsal",text:"Brief talk protocol with sentence starters.",
               outcome:"More participation; ideas and vocabulary emerge before drafting.",
               tradeoff:"Benefit: stronger meaning. Risk: time pressure later unless tight.",
               lensPrompt:"How does oral rehearsal support the oral-to-written progression and equitable participation?"},
              {label:"C",title:"Model paragraph spotlight",text:"Analyze a model paragraph for structure and features.",
               outcome:"Expectations become clearer; some may imitate without meaning.",
               tradeoff:"Benefit: clear target. Risk: form without voice unless guided.",
               lensPrompt:"How do you use models without replacing student meaning and identity?"}
            ]
          },
          {
            scene:"Students have ideas, but drafts still sound informal and repetitive. They need academic language without losing voice.",
            artifact:"Draft: ‚ÄúIt is good because good teachers.‚Äù\nPeer: ‚ÄúI don‚Äôt know more words.‚Äù",
            prompt:"What do you add before drafting again?",
            hint:"Choose a scaffold that supports academic language",
            lensHints:[
              "Use visuals to reduce cognitive load (organizers, color coding).",
              "Differentiate frames so they support rather than restrict.",
              "Keep meaning central: students choose their own examples."
            ],
            choices:[
              {label:"A",title:"Word bank + flexible sentence frames",text:"Targeted vocabulary and expandable frames.",
               outcome:"Writing becomes longer and clearer; more academic structures appear.",
               tradeoff:"Benefit: language support. Risk: formulaic writing if not personalized.",
               lensPrompt:"How do you keep frames supportive and still protect student voice?"},
              {label:"B",title:"Group drafting with roles",text:"Draft in groups to deepen ideas through talk.",
               outcome:"Ideas deepen; peer language support grows; participation can be uneven.",
               tradeoff:"Benefit: dialogic meaning-making. Risk: some voices disappear without structure.",
               lensPrompt:"What participation structure makes collaboration equitable?"},
              {label:"C",title:"Mini lesson on one writing feature",text:"Teach one feature (reasons/evidence), then apply.",
               outcome:"Writing gains focus; some need examples and visual support to apply well.",
               tradeoff:"Benefit: precision. Risk: overload if taught without a clear visual bridge.",
               lensPrompt:"What multimodal support bridges the concept into writing?"}
            ]
          },
          {
            scene:"Drafts exist. Students think revision means spelling only. You want critique, reasoning, and stronger evidence.",
            artifact:"Peer feedback: ‚ÄúGood.‚Äù\nStudent: ‚ÄúDo I just fix spelling?‚Äù",
            prompt:"How do you structure revision for critical thinking?",
            hint:"Choose a move that makes revision about meaning, evidence, clarity",
            lensHints:[
              "Revision = evaluating meaning + strengthening claims, not just editing.",
              "Make criteria visible: examples, checklists, and modeled decisions.",
              "Use talk to rehearse revision explanations before rewriting."
            ],
            choices:[
              {label:"A",title:"Revision checklist with categories",text:"Meaning, evidence, organization, language, with examples.",
               outcome:"Students revise ideas and structure, not only mechanics.",
               tradeoff:"Benefit: clarity. Risk: needs modeling to be used well.",
               lensPrompt:"How does explicit criteria support academic language and transfer?"},
              {label:"B",title:"Structured peer review prompts",text:"Sentence starters + targeted questions for feedback.",
               outcome:"Feedback becomes substantive; students practice academic discourse.",
               tradeoff:"Benefit: dialogic learning. Risk: shallow feedback without guidance.",
               lensPrompt:"How does structured talk expand access and participation?"},
              {label:"C",title:"Quick teacher conferences",text:"1‚Äì2 minute conferences focusing on one revision goal.",
               outcome:"High impact feedback; not everyone gets equal time.",
               tradeoff:"Benefit: precision. Risk: access and scalability constraints.",
               lensPrompt:"How do you protect access when time is limited?"}
            ]
          }
        ],
        badges: ["Scaffold Architect","Access Advocate"]
      },

      {
        id: "maze",
        title: "The Reading Barrier Maze",
        emoji: "üß≠", sigil: "RB", difficulty: 3,
        tags: ["Reading","Comprehension","Bridges"],
        blurb: "A dense text blocks comprehension. Find bridges that support meaning and transfer.",
        scenarioTitle: "Mission: The Reading Barrier Maze",
        goals: { access: 50, rigor: 55, voice: 35, timeSec: 270 },
        artifactDrop: "Concept-Map Compass",
        rounds: [
          {
            scene:"Students must read a dense academic text. Many can decode words but struggle to construct meaning and discuss it.",
            artifact:"Student note: ‚ÄúI read it but I don‚Äôt understand what it means.‚Äù",
            prompt:"How do you open the reading task?",
            hint:"Choose a move that builds a shared purpose for reading",
            lensHints:[
              "Multimodality can anchor meaning: visuals, headings, key terms.",
              "Access increases when the task has clear roles and supports.",
              "Meaning first, then language precision."
            ],
            choices:[
              {label:"A",title:"Cold read then quiz",text:"Students read silently and answer comprehension questions.",
               outcome:"A few succeed; many disengage or guess.",
               tradeoff:"Benefit: speed. Risk: low meaning-making and limited access.",
               lensPrompt:"What does this assume about prior knowledge and language resources?"},
              {label:"B",title:"Guided preview + purpose",text:"Preview headings, key terms, and set a purpose question.",
               outcome:"Students read with direction; comprehension improves.",
               tradeoff:"Benefit: clarity. Risk: needs a tight plan to avoid over-scaffolding.",
               lensPrompt:"How does this reduce cognitive load and support access?"},
              {label:"C",title:"Jigsaw roles + talk first",text:"Assign roles (summarizer, connector, questioner) before reading.",
               outcome:"Talk creates a reason to read; participation increases.",
               tradeoff:"Benefit: dialogic learning. Risk: uneven roles unless structured.",
               lensPrompt:"How do roles protect equitable participation?"}
            ]
          },
          {
            scene:"Students understand parts, but struggle to connect ideas across paragraphs. You want synthesis, not isolated facts.",
            artifact:"Student highlight: many words highlighted, little summary.",
            prompt:"How do you support synthesis?",
            hint:"Pick a visual or dialogic bridge across ideas",
            lensHints:[
              "Use a visual organizer to map relationships (claim, evidence, implication).",
              "Talk can rehearse synthesis before writing it.",
              "Keep the organizer simple and purposeful."
            ],
            choices:[
              {label:"A",title:"Concept map organizer",text:"Students map claims and evidence visually.",
               outcome:"Connections become visible; students synthesize more effectively.",
               tradeoff:"Benefit: strong meaning-making. Risk: can get messy without modeling.",
               lensPrompt:"How does a visual element support comprehension and biliteracy?"},
              {label:"B",title:"Sentence frames for synthesis",text:"Provide frames that require linking ideas (however, therefore).",
               outcome:"Students make connections in writing with clearer structure.",
               tradeoff:"Benefit: functional language. Risk: needs examples to avoid robotic use.",
               lensPrompt:"How do frames support academic function and student voice?"},
              {label:"C",title:"Teacher summary then discussion",text:"Teacher summarizes key points, then students discuss.",
               outcome:"More students can participate, but less independent synthesis occurs.",
               tradeoff:"Benefit: access. Risk: reduced student agency if overused.",
               lensPrompt:"Where is the balance between access support and learner agency?"}
            ]
          },
          {
            scene:"Now students must produce an analytic response. You want them to justify claims with evidence from the text.",
            artifact:"Student draft: ‚ÄúThe author is right.‚Äù (no evidence)",
            prompt:"How do you raise the level of critical thinking?",
            hint:"Choose a structure that forces evidence-based justification",
            lensHints:[
              "Make criteria visible: what counts as evidence and why.",
              "Use peer critique with prompts to demand justification.",
              "Require a ‚Äòwhy‚Äô and a ‚Äòbecause‚Äô supported by text."
            ],
            choices:[
              {label:"A",title:"Claim‚ÄìEvidence‚ÄìReasoning template",text:"Students fill a structured CER template.",
               outcome:"Evidence use improves; reasoning becomes explicit.",
               tradeoff:"Benefit: clarity. Risk: can feel constrained unless flexible.",
               lensPrompt:"How does structure support reasoning while still allowing voice?"},
              {label:"B",title:"Peer challenge protocol",text:"Peers must ask: ‚ÄúWhat‚Äôs your evidence?‚Äù and ‚ÄúWhy does it matter?‚Äù",
               outcome:"Students strengthen arguments; discussion becomes analytic.",
               tradeoff:"Benefit: dialogic critique. Risk: needs norms for respectful talk.",
               lensPrompt:"How does structured dialogue build critical thinking and participation?"},
              {label:"C",title:"Rubric exemplars",text:"Show two exemplar responses and analyze why one is stronger.",
               outcome:"Students internalize criteria and revise toward stronger evidence use.",
               tradeoff:"Benefit: clear target. Risk: may imitate unless asked to adapt.",
               lensPrompt:"How do exemplars support learning without producing copy-only responses?"}
            ]
          }
        ],
        badges: ["Barrier Breaker","Mode Mixer"]
      },

      {
        id: "puzzle",
        title: "The Participation Puzzle",
        emoji: "üó£Ô∏è", sigil: "PP", difficulty: 2,
        tags: ["Identity","Access","Dialogue"],
        blurb: "Some voices dominate and others disappear. Design equitable participation.",
        scenarioTitle: "Mission: The Participation Puzzle",
        goals: { access: 60, rigor: 40, voice: 55, timeSec: 240 },
        artifactDrop: "Dialogue Token",
        rounds: [
          {
            scene:"In online discussions, a few students post early and dominate. Others post late or not at all. You want dialogic exchange, not isolated posts.",
            artifact:"Thread pattern: 5 students post 80% of replies; many posts are ‚ÄúI agree.‚Äù",
            prompt:"How do you redesign discussion to increase dialogue?",
            hint:"Choose a structure that produces back-and-forth exchange",
            lensHints:[
              "Participation structures are equity structures.",
              "Make interaction requirements visible and doable.",
              "Use prompts that force application, not opinion only."
            ],
            choices:[
              {label:"A",title:"Keep as-is, add word count",text:"Require 250 words and 2 replies.",
               outcome:"Posts get longer, but dialogue quality may not improve.",
               tradeoff:"Benefit: easy to implement. Risk: longer but still shallow interaction.",
               lensPrompt:"Why might more words not equal more thinking or access?"},
              {label:"B",title:"Role-based discussion circles",text:"Assign roles (connector, challenger, summarizer) weekly.",
               outcome:"Replies become purposeful and varied; more students have entry points.",
               tradeoff:"Benefit: higher dialogue quality. Risk: needs clear role guidance.",
               lensPrompt:"How do roles support equitable participation and identity safety?"},
              {label:"C",title:"Structured response prompts",text:"Require evidence-based replies with sentence starters.",
               outcome:"Replies become more analytic and tied to readings.",
               tradeoff:"Benefit: academic discourse. Risk: can feel rigid unless flexible.",
               lensPrompt:"How do you balance structure with student voice?"}
            ]
          },
          {
            scene:"Some students feel uncertain about language accuracy and avoid posting. You want access without lowering rigor.",
            artifact:"Student message: ‚ÄúI‚Äôm afraid my English/Spanish is not perfect, so I don‚Äôt post.‚Äù",
            prompt:"What support increases access and keeps rigor?",
            hint:"Choose a move that lowers risk but preserves thinking demands",
            lensHints:[
              "Access can mean multiple modalities: audio, visuals, bilingual resources.",
              "Rigor can be in reasoning, not perfect grammar.",
              "Normalize drafting and revision."
            ],
            choices:[
              {label:"A",title:"Allow audio replies with transcript",text:"Students can reply with short audio plus a transcript.",
               outcome:"Participation increases and ideas become richer.",
               tradeoff:"Benefit: access. Risk: needs clear instructions for accessibility.",
               lensPrompt:"How does multimodality increase access while supporting academic discourse?"},
              {label:"B",title:"Bilingual planning allowed",text:"Students can plan ideas bilingually, then post in target language.",
               outcome:"Stronger ideas and confidence; better content quality.",
               tradeoff:"Benefit: identity affirming. Risk: needs boundaries to meet course goals.",
               lensPrompt:"How does this align with biliteracy development and Hornberger?"},
              {label:"C",title:"Grammar-first requirement",text:"Students must have near-perfect language accuracy.",
               outcome:"Some improve accuracy; many participate less and focus on form over meaning.",
               tradeoff:"Benefit: accuracy focus. Risk: reduced access and reduced critical thinking.",
               lensPrompt:"What gets lost when form becomes the main gatekeeper?"}
            ]
          },
          {
            scene:"Now you want students to demonstrate critical thinking: challenge ideas, connect theory, and propose implications.",
            artifact:"Most replies: ‚ÄúGreat point!‚Äù with no citation or application.",
            prompt:"How do you raise the level of thinking?",
            hint:"Choose a move that forces theory-based application",
            lensHints:[
              "Require students to apply a theory lens, not just agree/disagree.",
              "Use a ‚Äúclaim + warrant‚Äù structure tied to readings.",
              "Make the grading criteria visible."
            ],
            choices:[
              {label:"A",title:"Theory lens requirement",text:"Each reply must apply one author and explain relevance.",
               outcome:"Replies become analytic and grounded in readings.",
               tradeoff:"Benefit: rigor. Risk: needs clear examples so it‚Äôs not name-dropping.",
               lensPrompt:"How do you turn theory into reasoning rather than citations only?"},
              {label:"B",title:"Peer critique protocol",text:"Students must respectfully challenge one assumption with evidence.",
               outcome:"Dialogue becomes real; students practice academic critique.",
               tradeoff:"Benefit: critical thinking. Risk: needs norms to protect community.",
               lensPrompt:"How do norms and structure support identity-safe critique?"},
              {label:"C",title:"Case application prompt",text:"Each student applies discussion ideas to a classroom case.",
               outcome:"Strong transfer and relevance; posts show applied reasoning.",
               tradeoff:"Benefit: application. Risk: needs a good case library or student choice.",
               lensPrompt:"How does application demonstrate deeper understanding and transfer?"}
            ]
          }
        ],
        badges: ["Access Advocate","Theory Tactician"]
      },

      {
        id: "remix",
        title: "The Multimodal Remix Room",
        emoji: "üéõÔ∏è", sigil: "MM", difficulty: 1,
        tags: ["Multimodality","Design","Online"],
        blurb: "Design a low-friction multimodal assessment that increases critical thinking.",
        scenarioTitle: "Mission: The Multimodal Remix Room",
        goals: { access: 45, rigor: 35, voice: 45, timeSec: 210 },
        artifactDrop: "Alt-Text Amulet",
        rounds: [
          {
            scene:"You need to replace a discussion tool with something simple but more engaging. The goal is dialogic exchange and multimodal meaning-making.",
            artifact:"Constraint: must be low-cost, easy to access, and clearly tied to course objectives.",
            prompt:"What is your base format?",
            hint:"Choose a format that supports interaction and multimodality",
            lensHints:[
              "Choose the smallest tech that achieves the learning goal.",
              "Multimodality should reduce friction, not add it.",
              "Make the interaction requirement explicit."
            ],
            choices:[
              {label:"A",title:"Canvas discussion only",text:"Text posts + replies in Canvas.",
               outcome:"Reliable and simple, but can become repetitive without structure.",
               tradeoff:"Benefit: access. Risk: low novelty and weak multimodality.",
               lensPrompt:"What design features would increase dialogue and critical thinking?"},
              {label:"B",title:"Image-annotated discussion",text:"Students annotate an image/diagram and respond.",
               outcome:"More concrete talk; meaning anchored to visuals.",
               tradeoff:"Benefit: multimodal meaning. Risk: needs clear prompts and accessibility (alt text).",
               lensPrompt:"How do visuals increase critical thinking rather than decoration?"},
              {label:"C",title:"Short audio micro-dialogue",text:"Students post short audio + key points in text.",
               outcome:"Richer expression and tone; more conversational dialogue.",
               tradeoff:"Benefit: access and engagement. Risk: needs structure and accessibility.",
               lensPrompt:"How do you ensure equitable participation and assessment clarity?"}
            ]
          },
          {
            scene:"You want critical thinking. Students must evaluate, compare, and justify, not just share opinions.",
            artifact:"Goal: students must use readings to make a decision and defend it.",
            prompt:"What thinking task do you require?",
            hint:"Choose a task that forces evaluation and justification",
            lensHints:[
              "Use compare/contrast, decision-making, critique, or redesign.",
              "Require evidence from readings and implications for practice.",
              "Make the criteria visible."
            ],
            choices:[
              {label:"A",title:"Compare two approaches",text:"Students compare two strategies and argue for one in context.",
               outcome:"Clear analytic structure; encourages evidence-based reasoning.",
               tradeoff:"Benefit: strong critical thinking. Risk: needs well-defined approaches or options.",
               lensPrompt:"How do you connect comparison to real teaching decisions?"},
              {label:"B",title:"Critique an example",text:"Students critique a sample activity and propose revisions.",
               outcome:"Students practice evaluation and redesign.",
               tradeoff:"Benefit: authentic design thinking. Risk: needs a good sample and guidance.",
               lensPrompt:"How does redesign show transfer and deeper understanding?"},
              {label:"C",title:"Create then justify",text:"Students create a mini plan and justify each design choice.",
               outcome:"High transfer and ownership; strong alignment to practice.",
               tradeoff:"Benefit: synthesis. Risk: time demands if not bounded.",
               lensPrompt:"How do you keep it bounded and still rigorous?"}
            ]
          },
          {
            scene:"Now you need a grading approach that rewards reasoning and multimodal design, not just polish.",
            artifact:"Student concern: ‚ÄúDo I lose points if my visuals aren‚Äôt fancy?‚Äù",
            prompt:"What grading criteria do you emphasize?",
            hint:"Choose criteria that reward thinking, not aesthetics",
            lensHints:[
              "Grade reasoning, alignment, and accessibility over visual flair.",
              "Include theory integration and clarity of interaction.",
              "Make expectations transparent."
            ],
            choices:[
              {label:"A",title:"Reasoning-first rubric",text:"Theory use + justification + alignment are highest weight.",
               outcome:"Students focus on thinking and application.",
               tradeoff:"Benefit: fairness. Risk: must define what counts as strong justification.",
               lensPrompt:"How do you describe excellent reasoning in student-friendly terms?"},
              {label:"B",title:"Design-first rubric",text:"Visual polish and creativity are highest weight.",
               outcome:"Some beautiful work; can disadvantage students with less design experience.",
               tradeoff:"Benefit: aesthetics. Risk: inequity and reduced focus on learning goals.",
               lensPrompt:"How does this choice affect access and participation?"},
              {label:"C",title:"Balanced rubric + accessibility",text:"Reasoning and design both matter; accessibility is required.",
               outcome:"Students build functional multimodal work and defend choices.",
               tradeoff:"Benefit: well-rounded. Risk: needs concise rubric language to avoid confusion.",
               lensPrompt:"How do you keep the rubric simple and aligned to objectives?"}
            ]
          }
        ],
        badges: ["Mode Mixer","Critical Connector"]
      }
    ];

    const el = (id) => document.getElementById(id);

    const missionsEl = el("missions");
    const screenMissions = el("screenMissions");
    const screenScenario = el("screenScenario");
    const screenSubmit = el("screenSubmit");
    const screenSpellbook = el("screenSpellbook");

    const questMap = el("questMap");
    const progressBar = el("progressBar");
    const progressText = el("progressText");
    const xpVal = el("xpVal");
    const badgeVal = el("badgeVal");
    const levelPill = el("levelPill");
    const badgesList = el("badgesList");
    const resourcesRow = el("resourcesRow");
    const goalsText = el("goalsText");
    const perksList = el("perksList");
    const inventoryList = el("inventoryList");
    const runHistory = el("runHistory");
    const btnClearHistory = el("btnClearHistory");

    const scenarioTitle = el("scenarioTitle");
    const roundPill = el("roundPill");
    const runTimerPill = el("runTimerPill");
    const streakPill = el("streakPill");
    const roundMapPill = el("roundMapPill");
    const scenarioScene = el("scenarioScene");
    const scenarioArtifact = el("scenarioArtifact");
    const decisionPrompt = el("decisionPrompt");
    const decisionHint = el("decisionHint");
    const choicesEl = el("choices");

    const resultArea = el("resultArea");
    const outcomeText = el("outcomeText");
    const tradeoffText = el("tradeoffText");
    const lensPrompt = el("lensPrompt");
    const lensPop = el("lensPop");
    const btnShowLens = el("btnShowLens");
    const btnCoach = el("btnCoach");
    const coachPop = el("coachPop");
    const btnNext = el("btnNext");

    const justification = el("justification");
    const btnSaveJustification = el("btnSaveJustification");
    const justificationStatus = el("justificationStatus");

    const logText = el("logText");
    const btnCopyLog = el("btnCopyLog");
    const btnRenderPostInline = el("btnRenderPostInline");
    const btnFinish = el("btnFinish");

    const btnStart = el("btnStart");
    const btnSpellbook = el("btnSpellbook");
    const btnDaily = el("btnDaily");
    const btnDifficulty = el("btnDifficulty");
    const btnSound = el("btnSound");
    const btnMotion = el("btnMotion");
    const btnReset = el("btnReset");

    const spellbookEl = el("spellbook");

    const badgeSummary = el("badgeSummary");
    const btnCopyAll = el("btnCopyAll");
    const scoreboard = el("scoreboard");
    const rankNote = el("rankNote");
    const btnReplayMission = el("btnReplayMission");
    const replayCode = el("replayCode");
    const btnCopyReplayCode = el("btnCopyReplayCode");
    const btnLoadReplayCode = el("btnLoadReplayCode");
    const btnClearReplayView = el("btnClearReplayView");
    const compareCodeA = el("compareCodeA");
    const compareCodeB = el("compareCodeB");
    const btnCompareRuns = el("btnCompareRuns");
    const btnSwapRuns = el("btnSwapRuns");
    const compareStatus = el("compareStatus");

    const toast = el("toast");
    const postCanvas = el("postCanvas");
    const btnCopyPostImage = el("btnCopyPostImage");
    const btnDownloadPostImage = el("btnDownloadPostImage");
    const btnReRenderPost = el("btnReRenderPost");
    const postStatus = el("postStatus");
    const btnViewTimeline = el("btnViewTimeline");
    const btnViewDiagram = el("btnViewDiagram");
    const btnViewCompare = el("btnViewCompare");
    const postViewNote = el("postViewNote");
    const confettiEl = el("confetti");

    let TIMER_TICK = null;
    let AUDIO_CTX = null;
    let AUDIO_UNLOCKED = false;
    let VIEW_RUN = null; // when viewing history/replay (does not change XP)
    let VIEW_COMPARE = null; // {a: run, b: run}

    function showToast(msg){
      toast.textContent = msg;
      toast.style.display = "block";
      setTimeout(()=> toast.style.display="none", 1200);
    }

    function loadSettings(){
      try{
        const raw = localStorage.getItem("biliteracyQuest_settings_v1");
        const s = raw ? JSON.parse(raw) : {};
        const prefersReduced = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        STATE.soundOn = Boolean(s.soundOn ?? false);
        STATE.motionOn = Boolean(s.motionOn ?? !prefersReduced);
        STATE.dailyMode = Boolean(s.dailyMode ?? false);
        STATE.difficulty = String(s.difficulty ?? "normal");
      } catch(_e){
        // Defaults
        STATE.soundOn = false;
        STATE.motionOn = true;
        STATE.dailyMode = false;
        STATE.difficulty = "normal";
      }
      applySettingsToUI();
    }

    function saveSettings(){
      try{
        localStorage.setItem("biliteracyQuest_settings_v1", JSON.stringify({
          soundOn: STATE.soundOn,
          motionOn: STATE.motionOn,
          dailyMode: STATE.dailyMode,
          difficulty: STATE.difficulty
        }));
      } catch(_e){
        // ignore
      }
    }

    function applySettingsToUI(){
      if(btnSound) btnSound.textContent = "Sound: " + (STATE.soundOn ? "On" : "Off");
      if(btnMotion) btnMotion.textContent = "Motion: " + (STATE.motionOn ? "On" : "Off");
      if(btnDaily) btnDaily.textContent = STATE.dailyMode ? "Daily: On" : "Daily Challenge";
      if(btnDifficulty){
        const label = STATE.difficulty === "hard" ? "Hard" : (STATE.difficulty === "support" ? "Support" : "Normal");
        btnDifficulty.textContent = "Mode: " + label;
      }
      document.body.classList.toggle("reducedMotion", !STATE.motionOn);
    }

    function ensureAudio(){
      if(AUDIO_CTX) return AUDIO_CTX;
      try{
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if(!Ctx) return null;
        AUDIO_CTX = new Ctx();
        return AUDIO_CTX;
      } catch(_e){
        return null;
      }
    }

    async function unlockAudio(){
      if(AUDIO_UNLOCKED) return;
      const ctx = ensureAudio();
      if(!ctx) return;
      try{
        if(ctx.state === "suspended") await ctx.resume();
        AUDIO_UNLOCKED = true;
      } catch(_e){
        // ignore
      }
    }

    function playSfx(kind){
      if(!STATE.soundOn) return;
      const ctx = ensureAudio();
      if(!ctx) return;
      const now = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "triangle";
      let f = 440;
      let dur = 0.08;
      if(kind === "select"){ f = 520; dur = 0.06; }
      if(kind === "save"){ f = 680; dur = 0.08; }
      if(kind === "badge"){ f = 880; dur = 0.12; }
      if(kind === "fail"){ f = 220; dur = 0.10; o.type = "sawtooth"; }
      o.frequency.setValueAtTime(f, now);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.14, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      o.connect(g);
      g.connect(ctx.destination);
      o.start(now);
      o.stop(now + dur + 0.02);
    }

    function confettiBurst(){
      if(!STATE.motionOn) return;
      if(!confettiEl) return;
      // create ~30 pieces
      const colors = ["#F1B82D","#FFD86A","#111111","#0b7a3b","#ffffff"];
      const count = 34;
      const w = window.innerWidth || 1200;
      for(let i=0;i<count;i++){
        const bit = document.createElement("div");
        bit.className = "confettiBit";
        const x = (w * 0.2) + Math.random() * (w * 0.6);
        bit.style.left = x + "px";
        bit.style.top = (-20 - Math.random()*120) + "px";
        bit.style.background = colors[Math.floor(Math.random()*colors.length)];
        bit.style.transform = `translateY(-20px) rotate(${Math.random()*180}deg)`;
        bit.style.animationDuration = (700 + Math.random()*650) + "ms";
        bit.style.width = (8 + Math.random()*10) + "px";
        bit.style.height = (10 + Math.random()*16) + "px";
        confettiEl.appendChild(bit);
        setTimeout(()=> bit.remove(), 1400);
      }
    }

    function setStep(step){
      STATE.step = step;
      [...questMap.querySelectorAll(".checkpoint")].forEach(cp=>{
        const s = Number(cp.dataset.step);
        cp.classList.toggle("active", s === step);
        cp.classList.toggle("done", s < step);
      });

      const pct = (step / 4) * 100;
      progressBar.style.width = pct + "%";
      const labels = [
        "Choose a mission to begin.",
        "Make a decision and review outcomes.",
        "Consult theory to strengthen your justification.",
        "Build your decision path scroll.",
        "Copy and submit in Canvas."
      ];
      progressText.textContent = labels[step] || labels[0];
    }

    function getLevel(){
      return 1 + Math.floor(STATE.xp / 80);
    }

    function getUnlockedPerks(){
      const level = getLevel();
      return PERKS.filter(p=> level >= p.minLevel);
    }

    function hasPerk(id){
      return getUnlockedPerks().some(p=> p.id === id);
    }

    function saveProgress(){
      try{
        localStorage.setItem("biliteracyQuest_progress_v1", JSON.stringify({
          xp: STATE.xp,
          badges: STATE.badges,
          artifacts: STATE.artifacts
        }));
      } catch(_e){
        // ignore
      }
    }

    function loadProgress(){
      try{
        const raw = localStorage.getItem("biliteracyQuest_progress_v1");
        const p = raw ? JSON.parse(raw) : null;
        if(p && typeof p === "object"){
          STATE.xp = Number(p.xp || 0);
          STATE.badges = Array.isArray(p.badges) ? p.badges : [];
          STATE.artifacts = Array.isArray(p.artifacts) ? p.artifacts : [];
        }
      } catch(_e){
        // ignore
      }
    }

    function getRunHistory(){
      try{
        const raw = localStorage.getItem("biliteracyQuest_runs_v1");
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
      } catch(_e){
        return [];
      }
    }

    function setRunHistory(arr){
      try{
        localStorage.setItem("biliteracyQuest_runs_v1", JSON.stringify(arr));
      } catch(_e){
        // ignore
      }
    }

    function addRunToHistory(run){
      const runs = getRunHistory();
      runs.unshift(run);
      setRunHistory(runs.slice(0, 10));
    }

    function renderRunHistory(){
      if(!runHistory) return;
      const runs = getRunHistory();
      runHistory.innerHTML = "";
      if(!runs.length){
        const div = document.createElement("div");
        div.className = "tiny";
        div.textContent = "No runs yet. Finish a mission to see history here.";
        runHistory.appendChild(div);
        return;
      }
      runs.forEach((r, idx)=>{
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.gap = "8px";
        row.style.alignItems = "center";
        row.style.justifyContent = "space-between";
        row.style.flexWrap = "wrap";
        row.style.border = "1px solid var(--line)";
        row.style.borderRadius = "14px";
        row.style.padding = "10px";
        row.style.background = "linear-gradient(180deg,#fff,var(--soft))";

        const left = document.createElement("div");
        left.className = "tiny";
        left.style.color = "#222";
        left.style.maxWidth = "320px";
        left.style.lineHeight = "1.35";
        left.textContent = `${r.missionTitle || r.missionId || "Mission"} ‚Ä¢ ${r.rank || "‚Äî"} ‚Ä¢ +${r.runXpEarned || 0} XP ‚Ä¢ ${formatDuration(r.durationMs || 0)}`;

        const right = document.createElement("div");
        right.style.display = "flex";
        right.style.gap = "8px";
        right.style.flexWrap = "wrap";

        const btnView = document.createElement("button");
        btnView.type = "button";
        btnView.className = "miniBtn";
        btnView.textContent = "View";
        btnView.onclick = ()=>{
          VIEW_RUN = r;
          hydrateSubmitViewFromRun();
          screenSubmit.classList.remove("hidden");
          screenMissions.classList.add("hidden");
          screenScenario.classList.add("hidden");
          screenSpellbook.classList.add("hidden");
          setStep(4);
          renderCanvasPostSafe();
          showToast("Viewing run");
          window.scrollTo({top:0, behavior:"smooth"});
        };

        const btnCode = document.createElement("button");
        btnCode.type = "button";
        btnCode.className = "miniBtn miniBtnGold";
        btnCode.textContent = "Copy code";
        btnCode.onclick = ()=>{
          const code = buildReplayCode(r);
          copyText(code);
          showToast("Copied");
        };

        right.appendChild(btnView);
        right.appendChild(btnCode);
        row.appendChild(left);
        row.appendChild(right);
        runHistory.appendChild(row);
      });
    }

    function getActiveRunForView(){
      return VIEW_RUN || buildRunSnapshotFromState();
    }

    function b64urlEncodeUtf8(str){
      const b64 = btoa(unescape(encodeURIComponent(str)));
      return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
    }

    function b64urlDecodeUtf8(str){
      const b64 = str.replace(/-/g, "+").replace(/_/g, "/") + "===".slice((str.length + 3) % 4);
      return decodeURIComponent(escape(atob(b64)));
    }

    function buildRunSnapshotFromState(){
      const m = currentMission();
      const missionTitle = m ? m.title : "No mission selected";
      const durationMs = runElapsedMs();
      const impact = estimateImpact();
      const decisions = [...STATE.decisionLog].sort((a,b)=> a.round - b.round).map(e=> ({
        round: e.round,
        prompt: e.prompt,
        choice: e.choice,
        choiceIndex: typeof e.choiceIndex === "number" ? e.choiceIndex : null,
        outcome: e.outcome,
        tradeoff: e.tradeoff
      }));
      const choiceIdxs = decisions.map(d=> (typeof d.choiceIndex === "number" ? d.choiceIndex : null));
      const runXpEarned = Math.max(0, STATE.xp - (STATE.runXpStart || 0));
      const justificationsSaved = STATE.savedJustifications.length;
      const theoryJustifications = STATE.savedJustifications.filter(j=> containsTheory(j.text)).length;
      const lensHintsUsed = STATE.lensUsedRounds.length;
      const spellsUsed = STATE.appliedSpells.length;
      const supportSpent = Math.max(0, (STATE.supportTokensStart || 0) - (STATE.supportTokens || 0));
      const timeSpent = Math.max(0, (STATE.timeTokensStart || 0) - (STATE.timeTokens || 0));
      const hintsSpent = Math.max(0, (STATE.hintTokensStart || 0) - (STATE.hintTokens || 0));
      return {
        v: 1,
        runId: STATE.runId,
        seed: STATE.runSeed,
        daily: STATE.dailyMode,
        difficulty: STATE.difficulty,
        missionId: STATE.missionId,
        missionTitle,
        durationMs,
        rank: STATE.runRank,
        impact,
        score: {...STATE.score},
        runXpEarned,
        hintsUsed: STATE.hintUsedRounds.length,
        hintLog: STATE.hintLog.slice(0, 5),
        justificationsSaved,
        theoryJustifications,
        lensHintsUsed,
        spellsUsed,
        supportSpent,
        timeSpent,
        hintsSpent,
        choiceIdxs,
        decisions
      };
    }

    function buildDecisionScrollFromRun(run){
      const lines = [];
      lines.push("THE BILITERACY QUEST ‚Äì DECISION PATH SCROLL");
      lines.push("Mission: " + (run.missionTitle || run.missionId || "‚Äî"));
      if(run.runId) lines.push("Run ID: " + run.runId);
      if(typeof run.durationMs === "number") lines.push("Time: " + formatDuration(run.durationMs));
      if(run.difficulty) lines.push("Mode: " + run.difficulty);
      if(run.rank) lines.push("Run rank: " + run.rank);
      lines.push("");
      const path = (run.decisions || []).slice().sort((a,b)=> a.round - b.round);
      if(!path.length){
        lines.push("No decisions found.");
      } else {
        path.forEach(e=>{
          lines.push("Round " + e.round);
          lines.push("Prompt: " + e.prompt);
          lines.push("Choice: " + e.choice);
          lines.push("Outcome: " + e.outcome);
          lines.push("Tradeoff: " + e.tradeoff);
          lines.push("");
        });
      }
      const s = run.score || {base:0,theory:0,streak:0,spells:0,time:0};
      lines.push("IMPACT METERS (ESTIMATE)");
      lines.push("Access: " + (run.impact?.access ?? 0) + "/100");
      lines.push("Rigor: " + (run.impact?.rigor ?? 0) + "/100");
      lines.push("Voice: " + (run.impact?.voice ?? 0) + "/100");
      lines.push("");
      lines.push("Run XP earned: +" + (run.runXpEarned || 0));
      lines.push("Score breakdown: base " + (s.base||0) + ", theory " + (s.theory||0) + ", streak " + (s.streak||0) + ", spells " + (s.spells||0) + ", time " + (s.time||0));
      lines.push("");
      const ach = computeAchievements(run);
      if(ach.length){
        lines.push("ACHIEVEMENTS");
        ach.forEach(a=> lines.push(a.icon + " " + a.title));
        lines.push("");
      }
      lines.push("Replay code: " + buildReplayCode(run));
      return lines.join("\n");
    }

    function computeAchievements(run){
      const out = [];
      const durSec = Math.floor((run.durationMs || 0) / 1000);
      const perfect = run.rank === "VICTORY";
      const fast = durSec > 0 && durSec <= 180;
      const noCoach = (run.hintsUsed || 0) === 0;
      const noLens = (run.lensHintsUsed || 0) === 0;
      const noSpells = (run.spellsUsed || 0) === 0;
      const theoryMaster = (run.theoryJustifications || 0) >= 2;
      const fullJustifications = (run.justificationsSaved || 0) >= 3;
      const supportEff = (run.supportSpent || 0) <= 1;

      if(perfect) out.push({id:"perfectGoals", icon:"üèÜ", title:"Perfect Goals (Victory)"});
      if(fast) out.push({id:"fastFinish", icon:"‚ö°", title:"Fast Finish (‚â§ 3:00)"});
      if(fullJustifications && theoryMaster) out.push({id:"theoryMaster", icon:"üìö", title:"Theory Master (2+ theory justifications)"});
      if(noCoach) out.push({id:"noCoach", icon:"üß†", title:"No-Coach Run (0 hints)"});
      if(noLens && noSpells) out.push({id:"noSupport", icon:"üß±", title:"No-Support Run (no lens/spells)"});
      if(supportEff) out.push({id:"efficient", icon:"üß∞", title:"Support Efficient (‚â§ 1 support spent)"});

      return out.slice(0, 6);
    }

    function buildReplayPayload(run){
      return {
        v: 1,
        m: run.missionId,
        s: run.seed,
        c: (run.choiceIdxs || []).map(x=> (typeof x === "number" ? x : 0)),
        t: Math.floor((run.durationMs || 0) / 1000),
        r: run.rank || null,
        d: run.difficulty || "normal"
      };
    }

    function buildReplayCode(run){
      const payload = buildReplayPayload(run);
      const json = JSON.stringify(payload);
      return "BQ1:" + b64urlEncodeUtf8(json);
    }

    function runFromReplayPayload(payload){
      if(!payload || payload.v !== 1) return null;
      const missionId = payload.m;
      const mission = MISSIONS.find(mm=> mm.id === missionId);
      if(!mission) return null;
      const seed = (payload.s >>> 0);
      const choiceIdxs = Array.isArray(payload.c) ? payload.c : [];
      const decisions = [];
      for(let i=0;i<mission.rounds.length;i++){
        const rd = mission.rounds[i];
        const idx = Number(choiceIdxs[i] ?? 0);
        const choice = rd.choices[idx] || rd.choices[0];
        const entry = {
          round: i+1,
          prompt: rd.prompt,
          choice: `${choice.label}. ${choice.title}`,
          choiceIndex: Math.max(0, Math.min(rd.choices.length-1, idx)),
          outcome: choice.outcome,
          tradeoff: choice.tradeoff
        };
        decisions.push(entry);
      }
      const durationMs = Number(payload.t || 0) * 1000;
      const fakeState = {
        decisionLog: decisions,
        savedJustifications: [],
        appliedSpells: []
      };
      const impact = estimateImpactFromParts(fakeState);
      return {
        v: 1,
        runId: "REPLAY",
        seed,
        daily: false,
        difficulty: payload.d || "normal",
        missionId,
        missionTitle: mission.title,
        durationMs,
        rank: payload.r || "REPLAY",
        impact,
        score: { base:0, theory:0, streak:0, spells:0, time:0 },
        runXpEarned: 0,
        choiceIdxs: decisions.map(d=> d.choiceIndex),
        decisions
      };
    }

    function parseReplayCodeToRun(raw){
      const txt = String(raw || "").trim();
      if(!txt) return null;
      const code = txt.startsWith("BQ1:") ? txt.slice(4) : txt;
      const json = b64urlDecodeUtf8(code);
      const payload = JSON.parse(json);
      return runFromReplayPayload(payload);
    }

    function hydrateSubmitViewFromRun(){
      const run = getActiveRunForView();
      if(scoreboard){
        const s = run.score || {base:0,theory:0,streak:0,spells:0,time:0};
        const ach = computeAchievements(run);
        scoreboard.innerHTML = `
          <b>Run</b>: ${run.missionTitle || "‚Äî"}<br/>
          <b>Mode</b>: ${run.difficulty || "normal"} ‚Ä¢ <b>Rank</b>: ${run.rank || "‚Äî"} ‚Ä¢ <b>Time</b>: ${formatDuration(run.durationMs || 0)} ‚Ä¢ <b>Run XP</b>: +${run.runXpEarned || 0}<br/>
          <b>XP breakdown</b>: base ${s.base||0}, theory ${s.theory||0}, streak ${s.streak||0}, spells ${s.spells||0}, time ${s.time||0}<br/>
          <b>Impact</b>: Access ${run.impact?.access ?? "‚Äî"} ‚Ä¢ Rigor ${run.impact?.rigor ?? "‚Äî"} ‚Ä¢ Voice ${run.impact?.voice ?? "‚Äî"}<br/>
          <b>Achievements</b>: ${ach.length ? ach.map(a=> `${a.icon} ${a.title}`).join(" ‚Ä¢ ") : "‚Äî"}
        `;
      }
      if(rankNote) rankNote.textContent = run.rank ? `Rank: ${run.rank}` : "‚Äî";
      if(replayCode) replayCode.value = buildReplayCode(run);
    }

    function estimateImpactFromParts(parts){
      const text = [
        ...(parts.decisionLog || []).map(e=> `${e.choice} ${e.outcome} ${e.tradeoff}`),
        ...(parts.savedJustifications || []).map(j=> j.text),
        ...(parts.appliedSpells || [])
      ].join(" ").toLowerCase();
      const score = (words) => words.reduce((acc,w)=> acc + (text.includes(w) ? 1 : 0), 0);
      const access = score(["access","equity","equitable","participation","entry point","include","excluded","identity","voice","multilingual"]);
      const rigor  = score(["evidence","reasoning","analytic","analysis","precision","academic","justify","transfer","criteria","rubric"]);
      const voice  = score(["dialogue","discussion","talk","rehearsal","peer","collaboration","critique","norms","reply"]);
      const clamp01 = (n) => Math.max(0, Math.min(1, n));
      const a = clamp01(access / 10);
      const r = clamp01(rigor / 10);
      const v = clamp01(voice / 10);
      return { access: Math.round(a*100), rigor: Math.round(r*100), voice: Math.round(v*100) };
    }

    function renderResourcesAndGoals(){
      if(!resourcesRow || !goalsText) return;
      resourcesRow.innerHTML = "";
      const pills = [];
      pills.push({ cls:"tag tagGold", text:`‚è≥ Time ${STATE.timeTokens}` });
      pills.push({ cls:"tag tagDark", text:`üß∞ Support ${STATE.supportTokens}` });
      pills.push({ cls:"tag tagDark", text:`üí° Hints ${STATE.hintTokens}` });
      if(STATE.dailyMode) pills.push({ cls:"tag tagGreen", text:"Daily" });
      if(STATE.runSeed !== null) pills.push({ cls:"tag tagDark", text:`Seed ${String(STATE.runSeed).slice(0,6)}` });
      pills.forEach(p=>{
        const s = document.createElement("span");
        s.className = p.cls;
        s.textContent = p.text;
        resourcesRow.appendChild(s);
      });

      const m = currentMission();
      if(!m || !m.goals){
        goalsText.textContent = "Pick a mission to see its goals.";
        return;
      }
      const impact = estimateImpact();
      const diff = (STATE.difficulty === "hard" || STATE.difficulty === "support" || STATE.difficulty === "normal") ? STATE.difficulty : "normal";
      const timeTarget = m.goals.timeSec + (diff === "hard" ? -30 : (diff === "support" ? 30 : 0));
      const accessTarget = m.goals.access + (diff === "hard" ? 5 : (diff === "support" ? -5 : 0));
      const rigorTarget = m.goals.rigor + (diff === "hard" ? 5 : (diff === "support" ? -5 : 0));
      const voiceTarget = m.goals.voice + (diff === "hard" ? 5 : (diff === "support" ? -5 : 0));
      goalsText.textContent = `Goals (${diff}): Access ‚â• ${accessTarget}, Rigor ‚â• ${rigorTarget}, Voice ‚â• ${voiceTarget}, Time ‚â§ ${timeTarget}s. Current: A${impact.access} R${impact.rigor} V${impact.voice}, ${formatDuration(runElapsedMs())}.`;
    }

    function renderPerksAndInventory(){
      if(perksList){
        perksList.innerHTML = "";
        const perks = getUnlockedPerks();
        if(!perks.length){
          const span = document.createElement("span");
          span.className = "tag tagDark";
          span.textContent = "No perks yet (reach Level 2+)";
          perksList.appendChild(span);
        } else {
          perks.forEach(p=>{
            const span = document.createElement("span");
            span.className = "tag tagGold";
            span.title = p.blurb;
            span.textContent = p.title;
            perksList.appendChild(span);
          });
        }
      }
      if(inventoryList){
        inventoryList.innerHTML = "";
        if(!STATE.artifacts.length){
          const span = document.createElement("span");
          span.className = "tag tagDark";
          span.textContent = "No artifacts yet";
          inventoryList.appendChild(span);
        } else {
          STATE.artifacts.slice(0,10).forEach(a=>{
            const span = document.createElement("span");
            span.className = "tag tagGreen";
            span.textContent = a;
            inventoryList.appendChild(span);
          });
        }
      }
    }

    function updatePlayerPanel(){
      xpVal.textContent = STATE.xp;
      badgeVal.textContent = STATE.badges.length;
      const level = getLevel();
      levelPill.textContent = "Level " + level;

      badgesList.innerHTML = "";
      if(STATE.badges.length === 0){
        const span = document.createElement("span");
        span.className = "tag tagDark";
        span.textContent = "None yet";
        badgesList.appendChild(span);
      } else {
        STATE.badges.forEach(b=>{
          const span = document.createElement("span");
          span.className = "tag tagGold";
          span.textContent = b;
          badgesList.appendChild(span);
        });
      }

      renderResourcesAndGoals();
      renderPerksAndInventory();
      renderRunHistory();
    }

    function renderMissions(){
      missionsEl.innerHTML = "";
      MISSIONS.forEach(m=>{
        const div = document.createElement("div");
        div.className = "mission";
        const stars = "‚òÖ".repeat(m.difficulty) + "‚òÜ".repeat(Math.max(0,3-m.difficulty));

        div.innerHTML = `
          <div class="missionTop">
            <div>
              <div class="missionTitle">${m.title}</div>
              <div class="tagRow">
                ${(m.tags||[]).slice(0,3).map(t=> `<span class="tag ${t==="Gibbons"||t==="Multimodality" ? "tagGold" : "tagDark"}">${t}</span>`).join("")}
              </div>
            </div>
            <div class="difficulty"><span class="stars">${stars}</span></div>
          </div>

          <div class="missionArt">
            <div class="sigil">${m.sigil}</div>
            <div class="emoji">${m.emoji}</div>
            <div class="caption">${m.blurb}</div>
          </div>

          <div class="missionBottom">
            <div class="difficulty"><span>Difficulty</span><span class="stars">${stars}</span></div>
            <button type="button" class="btn btnGold" data-mission="${m.id}">Play Mission</button>
          </div>
        `;
        missionsEl.appendChild(div);
      });

      missionsEl.querySelectorAll("button[data-mission]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const id = btn.getAttribute("data-mission");
          startMission(id);
        });
      });
    }

    function currentMission(){
      return MISSIONS.find(m=> m.id === STATE.missionId);
    }
    function roundData(){
      const m = currentMission();
      if(!m) return null;
      return m.rounds[STATE.round];
    }

    function startMission(missionId){
      STATE.missionId = missionId;
      STATE.round = 0;
      STATE.decisionLog = [];
      STATE.savedJustifications = [];
      STATE.appliedSpells = [];
      STATE.streak = 0;
      STATE.runStartedAtMs = Date.now();
      STATE.runEndedAtMs = null;
      STATE.runId = makeRunId();
      STATE.runXpStart = STATE.xp;
      STATE.runSeed = (STATE.dailyMode ? (STATE.dailySeed ^ hash32(missionId)) : (hash32(STATE.runId) ^ (Date.now() >>> 0))) >>> 0;
      STATE.lensUsedRounds = [];

      // Run resources
      const diff = (STATE.difficulty === "hard" || STATE.difficulty === "support" || STATE.difficulty === "normal") ? STATE.difficulty : "normal";
      const baseTime = diff === "hard" ? 1 : (diff === "support" ? 3 : 2);
      const baseSupport = diff === "hard" ? 1 : (diff === "support" ? 4 : 2);
      const baseHints = diff === "hard" ? 0 : (diff === "support" ? 2 : 1);
      STATE.timeTokens = baseTime + (hasPerk("timeBank") ? 1 : 0);
      STATE.supportTokens = baseSupport + (hasPerk("supportSage") ? 1 : 0);
      STATE.hintTokens = baseHints;
      STATE.timeTokensStart = STATE.timeTokens;
      STATE.supportTokensStart = STATE.supportTokens;
      STATE.hintTokensStart = STATE.hintTokens;
      STATE.streakShieldUsed = false;
      STATE.hintUsedRounds = [];
      STATE.hintLog = [];

      // Reset score breakdown
      STATE.score = { base:0, theory:0, streak:0, spells:0, time:0 };

      setStep(1);
      screenMissions.classList.add("hidden");
      screenScenario.classList.remove("hidden");
      screenSubmit.classList.add("hidden");
      screenSpellbook.classList.add("hidden");

      renderRound();
      updateLog();
      updateRunHUD();
      updatePlayerPanel();
      startRunTimer();
      window.scrollTo({top:0, behavior:"smooth"});
    }

    function renderRound(){
      const m = currentMission();
      const r = roundData();
      if(!m || !r) return;

      scenarioTitle.textContent = m.scenarioTitle;
      roundPill.textContent = "Round " + (STATE.round + 1) + " of " + m.rounds.length;
      streakPill.textContent = "Streak " + STATE.streak;
      if(roundMapPill){
        const dots = [];
        for(let i=0;i<m.rounds.length;i++){
          if(i < STATE.round) dots.push("‚óè");
          else if(i === STATE.round) dots.push("‚óâ");
          else dots.push("‚óã");
        }
        roundMapPill.textContent = dots.join(" ");
      }

      const variant = getRoundVariant(m.id, STATE.round);
      scenarioScene.textContent = r.scene + (variant.scene ? ("\n\n" + variant.scene) : "");
      scenarioArtifact.textContent = r.artifact + (variant.artifact ? ("\n\n" + variant.artifact) : "");

      decisionPrompt.textContent = r.prompt;
      decisionHint.textContent = r.hint;

      choicesEl.innerHTML = "";
      resultArea.classList.add("hidden");
      lensPop.style.display = "none";
      if(coachPop) coachPop.style.display = "none";
      justification.value = "";
      justificationStatus.textContent = "Not saved yet";

      r.choices.forEach((c, idx)=>{
        const div = document.createElement("div");
        div.className = "choice";
        div.innerHTML = `
          <div class="cap">${c.label}. ${c.title} <span>Choose</span></div>
          <p>${c.text}</p>
        `;
        div.addEventListener("click", async ()=> {
          await unlockAudio();
          playSfx("select");
          selectChoice(idx, div);
        });
        choicesEl.appendChild(div);
      });
    }

    function selectChoice(idx, clickedEl){
      const r = roundData();
      const m = currentMission();
      if(!r || !m) return;

      // Visual selection
      [...choicesEl.querySelectorAll(".choice")].forEach(n=> n.classList.remove("selected","pop"));
      if(clickedEl){
        clickedEl.classList.add("selected","pop");
        setTimeout(()=> clickedEl.classList.remove("pop"), 260);
      }

      const c = r.choices[idx];

      outcomeText.textContent = c.outcome;
      tradeoffText.textContent = c.tradeoff;
      lensPrompt.textContent = c.lensPrompt;

      lensPop.innerHTML = `
        <strong>Lens Hints</strong>
        <ul>${r.lensHints.map(x=> `<li>${x}</li>`).join("")}</ul>
      `;

      resultArea.classList.remove("hidden");

      const entry = {
        round: STATE.round + 1,
        prompt: r.prompt,
        choice: `${c.label}. ${c.title}`,
        choiceIndex: idx,
        outcome: c.outcome,
        tradeoff: c.tradeoff
      };

      const existingIndex = STATE.decisionLog.findIndex(e=> e.round === entry.round);
      if(existingIndex >= 0) STATE.decisionLog[existingIndex] = entry;
      else STATE.decisionLog.push(entry);

      updateLog();

      btnShowLens.onclick = ()=>{
        const opening = lensPop.style.display !== "block";
        if(opening){
          const roundNum = STATE.round + 1;
          const alreadyUsed = STATE.lensUsedRounds.includes(roundNum);
          if(!alreadyUsed){
            if(STATE.supportTokens <= 0){
              playSfx("fail");
              showToast("Need a Support token to open lens hints");
              return;
            }
            STATE.supportTokens -= 1;
            STATE.lensUsedRounds.push(roundNum);
            playSfx("select");
            updatePlayerPanel();
          }
          lensPop.style.display = "block";
        } else {
          lensPop.style.display = "none";
        }
      };

      if(btnCoach && coachPop){
        btnCoach.onclick = ()=>{
          const roundNum = STATE.round + 1;
          const opening = coachPop.style.display !== "block";
          if(opening){
            const alreadyUsed = STATE.hintUsedRounds.includes(roundNum);
            if(!alreadyUsed){
              if(STATE.hintTokens <= 0){
                playSfx("fail");
                showToast("No Coach hints left");
                return;
              }
              STATE.hintTokens -= 1;
              STATE.hintUsedRounds.push(roundNum);
              const hint = buildCoachHint(r, c, entry);
              STATE.hintLog.push({ round: roundNum, hint });
              coachPop.innerHTML = `<strong>Coach Hint</strong><ul><li>${hint}</li></ul>`;
              playSfx("select");
              updatePlayerPanel();
              updateLog();
              renderCanvasPostSafe();
            } else {
              // Show the last hint we stored for this round
              const h = STATE.hintLog.find(x=> x.round === roundNum)?.hint || "Focus on the tradeoff and connect to one lens.";
              coachPop.innerHTML = `<strong>Coach Hint</strong><ul><li>${h}</li></ul>`;
            }
            coachPop.style.display = "block";
          } else {
            coachPop.style.display = "none";
          }
        };
      }

      btnNext.onclick = ()=> goNextRound();

      btnSaveJustification.onclick = ()=> saveJustification(entry);
    }

    function buildCoachHint(roundData, choice, entry){
      const hints = Array.isArray(roundData?.lensHints) ? roundData.lensHints : [];
      const pick = hints.length ? hints[0] : "Name one theory lens and explain why this choice improves access and learning.";
      const trade = entry?.tradeoff ? `One strong move is to acknowledge the tradeoff: ${entry.tradeoff}` : "Name one tradeoff and how you‚Äôd mitigate it.";
      return `${pick} ${trade}`;
    }

    function containsTheory(text){
      const t = text.toLowerCase();
      return t.includes("gibbons") || t.includes("hornberger") || t.includes("multimodal") || t.includes("academic") || t.includes("scaffold");
    }

    function makeRunId(){
      // Friendly, short, non-identifying run id
      return Math.random().toString(36).slice(2, 6).toUpperCase() + "-" + Math.random().toString(36).slice(2, 6).toUpperCase();
    }

    function computeDailySeed(){
      // Stable per-day seed (UTC) so everyone can compare runs.
      const d = new Date();
      const y = d.getUTCFullYear();
      const m = String(d.getUTCMonth()+1).padStart(2,"0");
      const day = String(d.getUTCDate()).padStart(2,"0");
      const key = `${y}-${m}-${day}`;
      return hash32("BQ:" + key);
    }

    function hash32(str){
      // FNV-1a 32-bit
      let h = 0x811c9dc5;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h >>> 0;
    }

    function mulberry32(seed){
      let a = seed >>> 0;
      return function(){
        a += 0x6D2B79F5;
        let t = a;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    const VARIANTS = {
      bridge: {
        scene: [
          "Variant: Two students ask to discuss ideas bilingually before writing.",
          "Variant: A student offers a strong oral example but lacks academic connectors.",
          "Variant: The class has limited time because an assembly was announced."
        ],
        artifact: [
          "Variant artifact: A quick oral transcript shows rich reasoning but missing transitions.",
          "Variant artifact: A student used a diagram; the draft doesn‚Äôt reference it yet.",
          "Variant artifact: Peer notes include one strong evidence example and two vague ones."
        ]
      },
      maze: {
        scene: [
          "Variant: The text includes unfamiliar domain vocabulary and dense nominalizations.",
          "Variant: Students are split‚Äîsome decode well, others rely on context clues.",
          "Variant: A student challenges the author‚Äôs claim but can‚Äôt cite the passage yet."
        ],
        artifact: [
          "Variant artifact: Highlights cover entire paragraphs with no margin notes.",
          "Variant artifact: A concept map is started but links are unlabeled.",
          "Variant artifact: A CER draft has a claim but the evidence is paraphrased without detail."
        ]
      },
      puzzle: {
        scene: [
          "Variant: A few students worry about public disagreement in a discussion board.",
          "Variant: Several students prefer audio responses, but want clarity on grading.",
          "Variant: Replies are frequent but rarely cite authors or readings."
        ],
        artifact: [
          "Variant artifact: A thread shows ‚ÄòI agree‚Äô replies with no warrants.",
          "Variant artifact: A student drafts in two languages, then posts a short summary.",
          "Variant artifact: A respectful critique starts strong but lacks evidence."
        ]
      },
      remix: {
        scene: [
          "Variant: One student has low bandwidth; another uses a phone only.",
          "Variant: Students ask for an example of ‚Äògood‚Äô multimodal work (not fancy).",
          "Variant: Students want to know how accessibility will be checked."
        ],
        artifact: [
          "Variant artifact: A visual post has no alt text and unclear labels.",
          "Variant artifact: A short audio post is strong but missing key points in text.",
          "Variant artifact: A rubric draft is too long‚Äîstudents miss the main criteria."
        ]
      }
    };

    function getRoundVariant(missionId, roundIndex){
      const key = String(missionId || "");
      const v = VARIANTS[key];
      if(!v || STATE.runSeed === null) return { scene:"", artifact:"" };
      const seed = (STATE.runSeed ^ hash32(key + ":" + String(roundIndex))) >>> 0;
      const rng = mulberry32(seed);
      const s = v.scene[Math.floor(rng() * v.scene.length)] || "";
      const a = v.artifact[Math.floor(rng() * v.artifact.length)] || "";
      return { scene: s, artifact: a };
    }

    function formatDuration(ms){
      const s = Math.max(0, Math.floor(ms / 1000));
      const mm = String(Math.floor(s / 60)).padStart(2,"0");
      const ss = String(s % 60).padStart(2,"0");
      return `${mm}:${ss}`;
    }

    function runElapsedMs(){
      if(!STATE.runStartedAtMs) return 0;
      const end = STATE.runEndedAtMs ?? Date.now();
      return Math.max(0, end - STATE.runStartedAtMs);
    }

    function updateRunHUD(){
      if(runTimerPill) runTimerPill.textContent = "‚è± " + formatDuration(runElapsedMs());
      if(streakPill) streakPill.textContent = "Streak " + STATE.streak;
    }

    function startRunTimer(){
      if(TIMER_TICK) clearInterval(TIMER_TICK);
      TIMER_TICK = setInterval(updateRunHUD, 400);
    }

    function stopRunTimer(){
      if(TIMER_TICK) clearInterval(TIMER_TICK);
      TIMER_TICK = null;
    }

    function addXP(amount, bucket){
      const n = Number(amount || 0);
      if(!n) return;
      STATE.xp += n;
      if(bucket && STATE.score && Object.prototype.hasOwnProperty.call(STATE.score, bucket)){
        STATE.score[bucket] += n;
      }
      saveProgress();
      updatePlayerPanel();
    }

    function saveJustification(entry){
      const text = justification.value.trim();
      if(text.length < 40){
        playSfx("fail");
        showToast("Add a bit more detail first");
        return;
      }

      const saved = { round: entry.round, text };
      const i = STATE.savedJustifications.findIndex(x=> x.round === saved.round);
      if(i >= 0) STATE.savedJustifications[i] = saved;
      else STATE.savedJustifications.push(saved);

      const base = 20;
      const theoryBonus = containsTheory(text) ? 15 : 0;
      const streakBonus = Math.min(25, STATE.streak * 5);
      addXP(base, "base");
      if(theoryBonus) addXP(theoryBonus, "theory");
      if(theoryBonus && hasPerk("scaffoldBoost")) addXP(10, "theory");
      if(streakBonus) addXP(streakBonus, "streak");

      STATE.streak += 1;
      updateRunHUD();

      justificationStatus.textContent = "Saved and XP earned";
      playSfx("save");
      showToast("Saved");
      updateLog();
      renderCanvasPostSafe();
      setStep(Math.max(STATE.step, 2));
    }

    function goNextRound(){
      const m = currentMission();
      if(!m) return;

      if(STATE.round < m.rounds.length - 1){
        // If the player advances without saving this round‚Äôs justification,
        // the XP streak breaks (game-like feedback loop).
        const currentRoundNumber = STATE.round + 1;
        const savedThisRound = STATE.savedJustifications.some(j=> j.round === currentRoundNumber);
        if(!savedThisRound) {
          const canShield = hasPerk("streakShield") && !STATE.streakShieldUsed && STATE.timeTokens > 0 && STATE.streak > 0;
          if(canShield){
            STATE.timeTokens -= 1;
            STATE.streakShieldUsed = true;
            playSfx("save");
            showToast("Streak Shield used (Time -1)");
          } else {
            STATE.streak = 0;
            playSfx("fail");
            updateRunHUD();
          }
          updatePlayerPanel();
        }

        STATE.round += 1;
        renderRound();
        updateLog();
        renderCanvasPostSafe();
        setStep(Math.max(STATE.step, 1));
      } else {
        finishMission();
      }
    }

    function finishMission(){
      const m = currentMission();
      if(!m) return;

      const usedTheory = STATE.savedJustifications.some(j => containsTheory(j.text));
      const badgePicks = [];
      badgePicks.push(m.badges?.[0] || "Quest Finisher");
      if(usedTheory) badgePicks.push(m.badges?.[1] || "Theory Tactician");

      const newlyUnlocked = [];
      badgePicks.forEach(b=>{
        if(!STATE.badges.includes(b)){
          STATE.badges.push(b);
          newlyUnlocked.push(b);
        }
      });

      // Completion XP
      addXP(30, "base");

      // Time bonus (mission goal)
      const elapsedSec = Math.floor(runElapsedMs() / 1000);
      if(m.goals?.timeSec){
        const diff = m.goals.timeSec - elapsedSec;
        if(diff >= 0){
          const bonus = 10 + Math.min(20, Math.floor(diff / 15));
          addXP(bonus, "time");
        }
      }

      // Artifact drop (meta-game)
      if(m.artifactDrop && !STATE.artifacts.includes(m.artifactDrop)){
        STATE.artifacts.push(m.artifactDrop);
        saveProgress();
      }

      // Rank based on goals
      const impact = estimateImpact();
      const goals = m.goals || null;
      if(goals){
        const diff = (STATE.difficulty === "hard" || STATE.difficulty === "support" || STATE.difficulty === "normal") ? STATE.difficulty : "normal";
        const timeTarget = goals.timeSec + (diff === "hard" ? -30 : (diff === "support" ? 30 : 0));
        const accessTarget = goals.access + (diff === "hard" ? 5 : (diff === "support" ? -5 : 0));
        const rigorTarget = goals.rigor + (diff === "hard" ? 5 : (diff === "support" ? -5 : 0));
        const voiceTarget = goals.voice + (diff === "hard" ? 5 : (diff === "support" ? -5 : 0));
        const met = impact.access >= accessTarget && impact.rigor >= rigorTarget && impact.voice >= voiceTarget && elapsedSec <= timeTarget;
        const close = (impact.access >= accessTarget && impact.rigor >= rigorTarget) || (impact.access >= accessTarget && impact.voice >= voiceTarget) || (impact.rigor >= rigorTarget && impact.voice >= voiceTarget);
        STATE.runRank = met ? "VICTORY" : (close ? "PARTIAL" : "TRY AGAIN");
      } else {
        STATE.runRank = "COMPLETE";
      }

      if(newlyUnlocked.length){
        playSfx("badge");
        confettiBurst();
      }

      STATE.runEndedAtMs = Date.now();
      stopRunTimer();
      updateRunHUD();
      recordBestRun();

      // Snapshot this run for submit screen + history
      VIEW_RUN = buildRunSnapshotFromState();
      addRunToHistory(VIEW_RUN);
      hydrateSubmitViewFromRun();

      setStep(4);
      screenScenario.classList.add("hidden");
      screenSubmit.classList.remove("hidden");
      screenMissions.classList.add("hidden");
      screenSpellbook.classList.add("hidden");

      badgeSummary.textContent = "Badges " + STATE.badges.length;
      showToast(STATE.runRank ? ("Run: " + STATE.runRank) : "Quest complete");
      updatePlayerPanel();
      // Default to the more explanatory export at the end.
      setPostView("diagram");
      renderCanvasPostSafe();
      window.scrollTo({top:0, behavior:"smooth"});
    }

    function recordBestRun(){
      try{
        const key = "biliteracyQuest_bestRun_v1";
        const best = JSON.parse(localStorage.getItem(key) || "null");
        const run = {
          xp: STATE.xp,
          badges: STATE.badges.length,
          missionId: STATE.missionId,
          durationMs: runElapsedMs(),
          endedAt: Date.now()
        };
        // Best = highest XP; tie-breaker = shorter time.
        const isBetter = !best || run.xp > best.xp || (run.xp === best.xp && run.durationMs < best.durationMs);
        if(isBetter) localStorage.setItem(key, JSON.stringify(run));
      } catch(_e){
        // ignore storage failures
      }
    }

    function estimateImpact(){
      // Lightweight ‚Äúreal game‚Äù feel: infer three meters from player-visible text.
      // Returns 0..100 values for Access / Rigor / Voice
      const text = [
        ...STATE.decisionLog.map(e=> `${e.choice} ${e.outcome} ${e.tradeoff}`),
        ...STATE.savedJustifications.map(j=> j.text),
        ...STATE.appliedSpells
      ].join(" ").toLowerCase();

      const score = (words) => words.reduce((acc,w)=> acc + (text.includes(w) ? 1 : 0), 0);
      const access = score(["access","equity","equitable","participation","entry point","include","excluded","identity","voice","multilingual"]);
      const rigor  = score(["evidence","reasoning","analytic","analysis","precision","academic","justify","transfer","criteria","rubric"]);
      const voice  = score(["dialogue","discussion","talk","rehearsal","peer","collaboration","critique","norms","reply"]);

      const clamp01 = (n) => Math.max(0, Math.min(1, n));
      // 0..1 normalized (soft caps)
      const a = clamp01(access / 10);
      const r = clamp01(rigor / 10);
      const v = clamp01(voice / 10);
      return { access: Math.round(a*100), rigor: Math.round(r*100), voice: Math.round(v*100) };
    }

    function updateLog(){
      const m = currentMission();
      const title = m ? m.title : "No mission selected";
      const lines = [];

      lines.push("THE BILITERACY QUEST ‚Äì DECISION PATH SCROLL");
      lines.push("Mission: " + title);
      if(STATE.runId) lines.push("Run ID: " + STATE.runId);
      if(STATE.runStartedAtMs) lines.push("Time: " + formatDuration(runElapsedMs()));
      lines.push("");

      if(STATE.decisionLog.length === 0){
        lines.push("Pick a mission and make a choice to generate your scroll.");
      } else {
        STATE.decisionLog
          .sort((a,b)=> a.round - b.round)
          .forEach(e=>{
            lines.push("Round " + e.round);
            lines.push("Prompt: " + e.prompt);
            lines.push("Choice: " + e.choice);
            lines.push("Outcome: " + e.outcome);
            lines.push("Tradeoff: " + e.tradeoff);
            lines.push("");
          });
      }

      if(STATE.savedJustifications.length){
        lines.push("SAVED JUSTIFICATION");
        STATE.savedJustifications
          .sort((a,b)=> a.round - b.round)
          .forEach(j=>{
            lines.push("Round " + j.round + " justification:");
            lines.push(j.text);
            lines.push("");
          });
      }

      if(STATE.appliedSpells.length){
        lines.push("APPLIED THEORY SPELLS");
        lines.push(STATE.appliedSpells.map(s=> "‚Ä¢ " + s).join("\n"));
        lines.push("");
      }

      const impact = estimateImpact();
      lines.push("IMPACT METERS (ESTIMATE)");
      lines.push("Access: " + impact.access + "/100");
      lines.push("Rigor: " + impact.rigor + "/100");
      lines.push("Voice: " + impact.voice + "/100");
      lines.push("");

      if(STATE.runRank) lines.push("Run rank: " + STATE.runRank);
      const runEarned = Math.max(0, STATE.xp - (STATE.runXpStart || 0));
      lines.push("Run XP earned: +" + runEarned);
      lines.push("Score breakdown: base " + (STATE.score.base||0) + ", theory " + (STATE.score.theory||0) + ", streak " + (STATE.score.streak||0) + ", spells " + (STATE.score.spells||0) + ", time " + (STATE.score.time||0));
      lines.push("");

      const code = buildReplayCode(buildRunSnapshotFromState());
      lines.push("Replay code: " + code);
      lines.push("");

      lines.push("Total XP: " + STATE.xp);
      lines.push("Badges: " + (STATE.badges.length ? STATE.badges.join(", ") : "None"));

      logText.textContent = lines.join("\n");
    }

    function copyText(text){
      // Clipboard API can fail on some contexts (e.g., file://). Provide a fallback.
      if(navigator.clipboard && navigator.clipboard.writeText){
        navigator.clipboard.writeText(text).then(()=> showToast("Copied")).catch(()=> fallbackCopy(text));
        return;
      }
      fallbackCopy(text);
    }

    function fallbackCopy(text){
      try{
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.setAttribute("readonly", "true");
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        ta.style.top = "0";
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand("copy");
        ta.remove();
        showToast(ok ? "Copied" : "Copy failed");
      } catch(_e){
        showToast("Copy failed");
      }
    }

    function wrapText(ctx, text, x, y, maxWidth, lineHeight, maxLines=Infinity){
      const words = (text || "").split(/\s+/).filter(Boolean);
      let line = "";
      let lines = 0;
      for(const word of words){
        const test = line ? line + " " + word : word;
        if(ctx.measureText(test).width > maxWidth && line){
          ctx.fillText(line, x, y);
          y += lineHeight;
          lines += 1;
          if(lines >= maxLines) return y;
          line = word;
        } else {
          line = test;
        }
      }
      if(line && lines < maxLines){
        ctx.fillText(line, x, y);
        y += lineHeight;
      }
      return y;
    }

    function drawPill(ctx, x, y, text, opts={}){
      const padX = opts.padX ?? 14;
      const padY = opts.padY ?? 9;
      const r = opts.radius ?? 16;
      ctx.font = opts.font ?? "700 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      const w = ctx.measureText(text).width + padX*2;
      const h = (opts.height ?? 40);
      ctx.save();
      ctx.fillStyle = opts.fill ?? "rgba(255,255,255,.10)";
      ctx.strokeStyle = opts.stroke ?? "rgba(241,184,45,.28)";
      ctx.lineWidth = 2;
      roundRect(ctx, x, y, w, h, r);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = opts.color ?? "rgba(255,255,255,.92)";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x + padX, y + h/2);
      ctx.restore();
      return {w, h};
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function drawQrToCanvas(ctx, text, x, y, size){
      if(typeof window.qrcode !== "function") return;
      try{
        const qr = window.qrcode(0, "M");
        qr.addData(String(text));
        qr.make();
        const count = qr.getModuleCount();
        const cell = Math.floor(size / count);
        const qrSize = cell * count;
        // background
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,.92)";
        roundRect(ctx, x-8, y-8, qrSize+16, qrSize+16, 12);
        ctx.fill();
        // modules
        for(let r=0;r<count;r++){
          for(let c=0;c<count;c++){
            if(qr.isDark(r,c)){
              ctx.fillStyle = "#111";
              ctx.fillRect(x + c*cell, y + r*cell, cell, cell);
            }
          }
        }
        ctx.restore();
      } catch(_e){
        // ignore
      }
    }

    function renderCanvasPostSafe(){
      try{ renderCanvasPost(); }
      catch(_e){ /* ignore render failures */ }
    }

    function renderCanvasPost(){
      if(!postCanvas) return;
      const ctx = postCanvas.getContext("2d");
      if(!ctx) return;

      const W = postCanvas.width;
      const H = postCanvas.height;

      const run = getActiveRunForView();

      // Switcher
      if(STATE.postView === "compare" && VIEW_COMPARE){
        renderCanvasCompare(ctx, W, H, VIEW_COMPARE.a, VIEW_COMPARE.b);
      } else if(STATE.postView === "diagram"){
        renderCanvasDiagram(ctx, W, H, run);
      } else {
        renderCanvasTimeline(ctx, W, H, run);
      }
    }

    function renderCanvasBase(ctx, W, H, run){
      // Background
      ctx.clearRect(0,0,W,H);
      const bg = ctx.createLinearGradient(0,0,W,H);
      bg.addColorStop(0, "#070709");
      bg.addColorStop(.55, "#101014");
      bg.addColorStop(1, "#060608");
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,W,H);

      // Accents
      const glow = ctx.createRadialGradient(W*0.2, H*0.15, 10, W*0.2, H*0.15, H*0.8);
      glow.addColorStop(0, "rgba(241,184,45,.30)");
      glow.addColorStop(1, "rgba(241,184,45,0)");
      ctx.fillStyle = glow;
      ctx.fillRect(0,0,W,H);

      // Header
      const title = run.missionTitle || "Biliteracy Quest";
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "900 44px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "top";
      ctx.fillText("THE BILITERACY QUEST", 56, 42);

      ctx.fillStyle = "rgba(255,255,255,.80)";
      ctx.font = "800 30px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Mission: " + title, 56, 98);

      // Meta pills
      let px = 56, py = 148;
      const meta = [];
      if(run.runId) meta.push("Run " + run.runId);
      meta.push("Time " + formatDuration(run.durationMs || 0));
      if(run.rank) meta.push(run.rank);
      meta.push("Run XP +" + (run.runXpEarned || 0));
      meta.forEach((t)=>{
        const pill = drawPill(ctx, px, py, t);
        px += pill.w + 12;
      });
    }

    function renderCanvasTimeline(ctx, W, H, run){
      renderCanvasBase(ctx, W, H, run);

      // Background
      // (base drawn above)

      // Main card
      const cardX = 56, cardY = 214, cardW = W - 112, cardH = H - 270;
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.06)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      roundRect(ctx, cardX, cardY, cardW, cardH, 28);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // Path timeline
      const path = [...(run.decisions || [])].sort((a,b)=> a.round - b.round);
      const left = cardX + 44;
      const top = cardY + 40;
      const right = cardX + cardW - 44;
      const lineX = left + 22;
      const rowGap = 120;

      // Vertical line
      ctx.save();
      ctx.strokeStyle = "rgba(241,184,45,.55)";
      ctx.lineWidth = 6;
      ctx.lineCap = "round";
      const lineTop = top + 18;
      const lineBot = top + Math.max(0, (path.length-1))*rowGap + 18;
      ctx.beginPath();
      ctx.moveTo(lineX, lineTop);
      ctx.lineTo(lineX, lineBot);
      ctx.stroke();
      ctx.restore();

      // Nodes + text
      ctx.textBaseline = "top";
      path.forEach((e, i)=>{
        const y = top + i*rowGap;

        // Node
        ctx.save();
        ctx.fillStyle = "#F1B82D";
        ctx.shadowColor = "rgba(241,184,45,.35)";
        ctx.shadowBlur = 18;
        ctx.beginPath();
        ctx.arc(lineX, y + 18, 16, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.fillStyle = "#111";
        ctx.font = "900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(e.round), lineX, y + 18);
        ctx.restore();

        // Text block
        const tx = lineX + 34;
        const maxW = right - tx;
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "900 24px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText("Round " + e.round + " ‚Ä¢ " + e.choice, tx, y);

        ctx.fillStyle = "rgba(255,255,255,.80)";
        ctx.font = "650 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        let yy = y + 34;
        yy = wrapText(ctx, "Outcome: " + e.outcome, tx, yy, maxW, 22, 2);
        ctx.fillStyle = "rgba(255,255,255,.66)";
        wrapText(ctx, "Tradeoff: " + e.tradeoff, tx, yy, maxW, 22, 2);
      });

      // Footer: badges + spells (as tags)
      const impact = run.impact || {access:0, rigor:0, voice:0};
      const footerY = cardY + cardH - 62;
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.70)";
      ctx.font = "800 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "middle";
      ctx.fillText("Impact: Access " + impact.access + " ‚Ä¢ Rigor " + impact.rigor + " ‚Ä¢ Voice " + impact.voice, cardX + 44, footerY);
      ctx.restore();

      // QR code (replay)
      const code = buildReplayCode(run);
      drawQrToCanvas(ctx, code, W - 56 - 160, cardY + cardH - 160, 160);

      // Small note for Canvas
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.46)";
      ctx.font = "650 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "bottom";
      ctx.fillText("Copy/paste or upload this image into Canvas. Text scroll recommended for accessibility.", 56, H - 22);
      ctx.restore();
    }

    function renderCanvasDiagram(ctx, W, H, run){
      renderCanvasBase(ctx, W, H, run);

      const cardX = 56, cardY = 214, cardW = W - 112, cardH = H - 270;
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.06)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      roundRect(ctx, cardX, cardY, cardW, cardH, 28);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      const path = [...(run.decisions || [])].sort((a,b)=> a.round - b.round);
      const leftPaneW = Math.floor(cardW * 0.62);
      const rightPaneX = cardX + leftPaneW + 22;
      const rightPaneW = cardX + cardW - 44 - rightPaneX;

      // Flowchart nodes (left)
      const nodeX = cardX + 36;
      let y = cardY + 30;
      const nodeW = leftPaneW - 72;
      const nodeH = 110;
      const gap = 22;

      path.forEach((e, i)=>{
        // connector arrow from previous
        if(i > 0){
          const ax = nodeX + 30;
          const ay1 = y - gap + 4;
          const ay2 = y - 8;
          ctx.save();
          ctx.strokeStyle = "rgba(241,184,45,.55)";
          ctx.lineWidth = 5;
          ctx.lineCap = "round";
          ctx.beginPath();
          ctx.moveTo(ax, ay1);
          ctx.lineTo(ax, ay2);
          ctx.stroke();
          // arrow head
          ctx.fillStyle = "rgba(241,184,45,.85)";
          ctx.beginPath();
          ctx.moveTo(ax, ay2);
          ctx.lineTo(ax - 8, ay2 - 10);
          ctx.lineTo(ax + 8, ay2 - 10);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }

        // node box
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,.08)";
        ctx.strokeStyle = "rgba(241,184,45,.25)";
        ctx.lineWidth = 2;
        roundRect(ctx, nodeX, y, nodeW, nodeH, 22);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // round badge
        ctx.save();
        ctx.fillStyle = "#F1B82D";
        ctx.beginPath();
        ctx.arc(nodeX + 26, y + 26, 16, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#111";
        ctx.font = "900 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(e.round), nodeX + 26, y + 26);
        ctx.restore();

        // node text
        const tx = nodeX + 54;
        const maxW = nodeW - 70;
        ctx.save();
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "900 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        wrapText(ctx, e.choice || `Round ${e.round}`, tx, y + 12, maxW, 24, 1);
        ctx.fillStyle = "rgba(255,255,255,.76)";
        ctx.font = "650 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        let yy = y + 40;
        yy = wrapText(ctx, "Outcome: " + (e.outcome || ""), tx, yy, maxW, 22, 2);
        ctx.fillStyle = "rgba(255,255,255,.60)";
        wrapText(ctx, "Tradeoff: " + (e.tradeoff || ""), tx, yy, maxW, 22, 2);
        ctx.restore();

        y += nodeH + gap;
      });

      // Summary panel (right)
      const paneY = cardY + 30;
      const paneH = cardH - 60;
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.20)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      roundRect(ctx, rightPaneX, paneY, rightPaneW, paneH, 22);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      const impact = run.impact || {access:0, rigor:0, voice:0};
      const s = run.score || {base:0,theory:0,streak:0,spells:0,time:0};
      let py = paneY + 16;
      const px = rightPaneX + 16;
      const pw = rightPaneW - 32;

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "900 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "top";
      ctx.fillText("Run Summary", px, py);
      py += 30;

      ctx.fillStyle = "rgba(255,255,255,.72)";
      ctx.font = "700 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      wrapText(ctx, `Rank: ${run.rank || "‚Äî"}`, px, py, pw, 20, 1);
      py += 22;
      wrapText(ctx, `Run XP: +${run.runXpEarned || 0}`, px, py, pw, 20, 1);
      py += 26;
      wrapText(ctx, `Coach hints: ${run.hintsUsed || 0}`, px, py, pw, 20, 1);
      py += 26;

      ctx.fillStyle = "rgba(255,255,255,.86)";
      ctx.font = "900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Impact meters", px, py);
      py += 22;

      function bar(label, val, color){
        ctx.fillStyle = "rgba(255,255,255,.70)";
        ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.fillText(label + " " + val + "/100", px, py);
        py += 16;
        // track
        ctx.fillStyle = "rgba(255,255,255,.10)";
        roundRect(ctx, px, py, pw, 10, 6);
        ctx.fill();
        // fill
        ctx.fillStyle = color;
        roundRect(ctx, px, py, Math.max(8, Math.floor((val/100)*pw)), 10, 6);
        ctx.fill();
        py += 18;
      }
      bar("Access", impact.access, "rgba(241,184,45,.90)");
      bar("Rigor", impact.rigor, "rgba(255,255,255,.78)");
      bar("Voice", impact.voice, "rgba(11,122,59,.70)");
      py += 8;

      ctx.fillStyle = "rgba(255,255,255,.86)";
      ctx.font = "900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Score breakdown", px, py);
      py += 22;

      ctx.fillStyle = "rgba(255,255,255,.70)";
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      const lines = [
        `Base: ${s.base||0}`,
        `Theory: ${s.theory||0}`,
        `Streak: ${s.streak||0}`,
        `Spells: ${s.spells||0}`,
        `Time: ${s.time||0}`
      ];
      lines.forEach(line=>{
        ctx.fillText(line, px, py);
        py += 18;
      });

      py += 10;
      ctx.fillStyle = "rgba(255,255,255,.86)";
      ctx.font = "900 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Achievements", px, py);
      py += 22;
      ctx.fillStyle = "rgba(255,255,255,.70)";
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      const ach = computeAchievements(run);
      if(!ach.length){
        ctx.fillText("‚Äî", px, py);
        py += 18;
      } else {
        ach.slice(0, 4).forEach(a=>{
          wrapText(ctx, `${a.icon} ${a.title}`, px, py, pw, 18, 1);
          py += 18;
        });
      }
      ctx.restore();

      // QR code (replay)
      const code = buildReplayCode(run);
      drawQrToCanvas(ctx, code, W - 56 - 160, cardY + cardH - 160, 160);

      // footer note
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.46)";
      ctx.font = "650 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "bottom";
      ctx.fillText("Diagram view: a flowchart + summary panel. Scan QR to load this run.", 56, H - 22);
      ctx.restore();
    }

    function renderCanvasCompare(ctx, W, H, runA, runB){
      // Base background + custom header
      ctx.clearRect(0,0,W,H);
      const bg = ctx.createLinearGradient(0,0,W,H);
      bg.addColorStop(0, "#070709");
      bg.addColorStop(.55, "#101014");
      bg.addColorStop(1, "#060608");
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,W,H);
      const glow = ctx.createRadialGradient(W*0.2, H*0.15, 10, W*0.2, H*0.15, H*0.8);
      glow.addColorStop(0, "rgba(241,184,45,.30)");
      glow.addColorStop(1, "rgba(241,184,45,0)");
      ctx.fillStyle = glow;
      ctx.fillRect(0,0,W,H);

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "900 44px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "top";
      ctx.fillText("RUN COMPARISON", 56, 42);
      ctx.fillStyle = "rgba(255,255,255,.72)";
      ctx.font = "800 22px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillText("Side-by-side path diagram", 56, 98);

      const cardX = 56, cardY = 150, cardW = W - 112, cardH = H - 190;
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.06)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      roundRect(ctx, cardX, cardY, cardW, cardH, 28);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      const gutter = 18;
      const colW = Math.floor((cardW - gutter - 44) / 2);
      const colX1 = cardX + 22;
      const colX2 = colX1 + colW + gutter;
      const colY = cardY + 22;
      const colH = cardH - 44;

      const diffs = computeChoiceDiffs(runA, runB);
      drawCompareColumn(ctx, colX1, colY, colW, colH, "RUN A", runA, diffs, "A");
      drawCompareColumn(ctx, colX2, colY, colW, colH, "RUN B", runB, diffs, "B");

      // Footer note
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.46)";
      ctx.font = "650 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "bottom";
      ctx.fillText("Highlighted rounds differ between runs. Each column includes its replay QR.", 56, H - 18);
      ctx.restore();
    }

    function computeChoiceDiffs(a, b){
      const aa = Array.isArray(a?.choiceIdxs) ? a.choiceIdxs : [];
      const bb = Array.isArray(b?.choiceIdxs) ? b.choiceIdxs : [];
      const n = Math.max(aa.length, bb.length);
      const diffs = new Array(n).fill(false);
      for(let i=0;i<n;i++){
        const x = aa[i];
        const y = bb[i];
        diffs[i] = (typeof x === "number" && typeof y === "number") ? (x !== y) : (String(x) !== String(y));
      }
      return diffs;
    }

    function drawCompareColumn(ctx, x, y, w, h, title, run, diffs, side){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.18)";
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      roundRect(ctx, x, y, w, h, 22);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      const pad = 16;
      let cy = y + pad;
      const cx = x + pad;
      const cw = w - pad*2;

      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "900 20px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.textBaseline = "top";
      ctx.fillText(title, cx, cy);
      cy += 24;
      ctx.fillStyle = "rgba(255,255,255,.78)";
      ctx.font = "800 18px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      wrapText(ctx, run.missionTitle || run.missionId || "‚Äî", cx, cy, cw, 20, 1);
      cy += 22;
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillStyle = "rgba(255,255,255,.70)";
      ctx.fillText(`Mode: ${run.difficulty || "normal"} ‚Ä¢ Rank: ${run.rank || "‚Äî"} ‚Ä¢ ${formatDuration(run.durationMs || 0)}`, cx, cy);
      cy += 22;
      ctx.fillText(`Impact: A${run.impact?.access ?? 0} R${run.impact?.rigor ?? 0} V${run.impact?.voice ?? 0}`, cx, cy);
      cy += 22;

      // Choices list
      ctx.font = "900 16px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      ctx.fillStyle = "rgba(255,255,255,.86)";
      ctx.fillText("Path", cx, cy);
      cy += 18;

      const decisions = (run.decisions || []).slice().sort((a,b)=> a.round - b.round);
      ctx.font = "700 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
      decisions.forEach((d, i)=>{
        const diff = diffs[i];
        ctx.fillStyle = diff ? "rgba(241,184,45,.92)" : "rgba(255,255,255,.70)";
        const line = `R${d.round}: ${d.choice}`;
        wrapText(ctx, line, cx, cy, cw, 18, 1);
        cy += 18;
        if(diff){
          ctx.fillStyle = "rgba(255,255,255,.55)";
          wrapText(ctx, "‚Ä¢ differs from other run", cx + 14, cy, cw - 14, 16, 1);
          cy += 16;
        }
      });

      // QR (bottom)
      const code = buildReplayCode(run);
      const qrSize = Math.min(140, Math.floor(w * 0.42));
      drawQrToCanvas(ctx, code, x + w - qrSize - 18, y + h - qrSize - 18, qrSize);

      ctx.restore();
    }

    async function copyPostImage(){
      if(!postCanvas) return;
      postStatus.textContent = "Copying‚Ä¶";
      renderCanvasPostSafe();
      const blob = await new Promise((resolve)=> postCanvas.toBlob(resolve, "image/png"));
      if(!blob){
        postStatus.textContent = "Could not render image";
        showToast("Copy failed");
        return;
      }
      try{
        if(navigator.clipboard && window.ClipboardItem){
          await navigator.clipboard.write([new ClipboardItem({"image/png": blob})]);
          postStatus.textContent = "Copied image";
          showToast("Copied");
          return;
        }
        // Fallback: download
        downloadBlob(blob, "biliteracy-quest-path.png");
        postStatus.textContent = "Downloaded (copy not supported)";
        showToast("Downloaded");
      } catch(_e){
        // Fallback: download
        downloadBlob(blob, "biliteracy-quest-path.png");
        postStatus.textContent = "Downloaded (clipboard blocked)";
        showToast("Downloaded");
      }
    }

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 500);
    }

    async function downloadPostImage(){
      if(!postCanvas) return;
      postStatus.textContent = "Preparing download‚Ä¶";
      renderCanvasPostSafe();
      const blob = await new Promise((resolve)=> postCanvas.toBlob(resolve, "image/png"));
      if(!blob){
        postStatus.textContent = "Could not render image";
        return;
      }
      downloadBlob(blob, "biliteracy-quest-path.png");
      postStatus.textContent = "Downloaded PNG";
      showToast("Downloaded");
    }

    // Buttons
    btnCopyLog.addEventListener("click", async ()=> {
      await unlockAudio();
      playSfx("select");
      copyText(logText.textContent);
    });
    btnRenderPostInline.addEventListener("click", ()=>{
      unlockAudio();
      playSfx("select");
      renderCanvasPostSafe();
      showToast("Updated");
    });
    btnFinish.addEventListener("click", async ()=> {
      await unlockAudio();
      playSfx("select");
      finishMission();
    });
    btnCopyAll.addEventListener("click", async ()=> {
      await unlockAudio();
      playSfx("select");
      const run = getActiveRunForView();
      copyText(buildDecisionScrollFromRun(run));
    });
    if(btnCopyPostImage) btnCopyPostImage.addEventListener("click", async ()=> {
      await unlockAudio();
      playSfx("select");
      copyPostImage();
    });
    if(btnDownloadPostImage) btnDownloadPostImage.addEventListener("click", async ()=> {
      await unlockAudio();
      playSfx("select");
      downloadPostImage();
    });
    if(btnReRenderPost) btnReRenderPost.addEventListener("click", ()=>{
      unlockAudio();
      playSfx("select");
      renderCanvasPostSafe();
      postStatus.textContent = "Re-rendered";
      showToast("Updated");
    });

    function setPostView(view){
      const v = (view === "diagram" || view === "compare") ? view : "timeline";
      if(v === "compare" && !VIEW_COMPARE){
        showToast("Paste two codes and click Compare first");
        return;
      }
      STATE.postView = v;
      if(btnViewTimeline) btnViewTimeline.classList.toggle("miniBtnGold", STATE.postView === "timeline");
      if(btnViewDiagram) btnViewDiagram.classList.toggle("miniBtnGold", STATE.postView === "diagram");
      if(btnViewCompare) btnViewCompare.classList.toggle("miniBtnGold", STATE.postView === "compare");
      if(postViewNote){
        postViewNote.textContent =
          (STATE.postView === "diagram") ? "Diagram view" :
          (STATE.postView === "compare") ? "Compare view" :
          "Timeline view";
      }
      renderCanvasPostSafe();
    }

    if(btnViewTimeline) btnViewTimeline.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      setPostView("timeline");
    });
    if(btnViewDiagram) btnViewDiagram.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      setPostView("diagram");
    });
    if(btnViewCompare) btnViewCompare.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      setPostView("compare");
    });

    if(btnReplayMission) btnReplayMission.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      const run = getActiveRunForView();
      if(!run.missionId){
        showToast("No mission to replay");
        return;
      }
      VIEW_RUN = null;
      startMission(run.missionId);
    });

    if(btnCopyReplayCode) btnCopyReplayCode.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      if(replayCode) copyText(replayCode.value.trim());
    });

    if(btnLoadReplayCode) btnLoadReplayCode.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      const raw = (replayCode ? replayCode.value.trim() : "");
      if(!raw){
        showToast("Paste a code first");
        return;
      }
      try{
        const run = parseReplayCodeToRun(raw);
        if(!run){
          showToast("Invalid code");
          return;
        }
        VIEW_RUN = run;
        hydrateSubmitViewFromRun();
        renderCanvasPostSafe();
        showToast("Replay loaded");
      } catch(_e){
        showToast("Invalid code");
      }
    });

    if(btnCompareRuns) btnCompareRuns.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      const aRaw = compareCodeA ? compareCodeA.value.trim() : "";
      const bRaw = compareCodeB ? compareCodeB.value.trim() : "";
      if(!aRaw || !bRaw){
        if(compareStatus) compareStatus.textContent = "Paste both codes";
        showToast("Paste both codes");
        return;
      }
      try{
        const a = parseReplayCodeToRun(aRaw);
        const b = parseReplayCodeToRun(bRaw);
        if(!a || !b){
          if(compareStatus) compareStatus.textContent = "Invalid code(s)";
          showToast("Invalid code(s)");
          return;
        }
        VIEW_COMPARE = {a, b};
        if(compareStatus){
          compareStatus.textContent = (a.missionId === b.missionId) ? "Ready (same mission)" : "Ready (different missions)";
        }
        setPostView("compare");
        showToast("Compare view");
      } catch(_e){
        if(compareStatus) compareStatus.textContent = "Invalid code(s)";
        showToast("Invalid code(s)");
      }
    });

    if(btnSwapRuns) btnSwapRuns.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      if(!compareCodeA || !compareCodeB) return;
      const tmp = compareCodeA.value;
      compareCodeA.value = compareCodeB.value;
      compareCodeB.value = tmp;
      showToast("Swapped");
    });

    if(btnClearReplayView) btnClearReplayView.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      VIEW_RUN = null;
      hydrateSubmitViewFromRun();
      renderCanvasPostSafe();
      showToast("Exited replay view");
    });

    btnStart.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      setStep(0);
      screenMissions.classList.remove("hidden");
      screenScenario.classList.add("hidden");
      screenSubmit.classList.add("hidden");
      screenSpellbook.classList.add("hidden");
      stopRunTimer();
      window.scrollTo({top:0, behavior:"smooth"});
    });

    btnSpellbook.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      screenSpellbook.classList.toggle("hidden");
      screenMissions.classList.add("hidden");
      screenScenario.classList.add("hidden");
      screenSubmit.classList.add("hidden");
      renderSpellbook();
      setStep(Math.max(STATE.step, 2));
      window.scrollTo({top:0, behavior:"smooth"});
    });

    if(btnDaily) btnDaily.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      STATE.dailyMode = !STATE.dailyMode;
      if(STATE.dailyMode){
        STATE.dailySeed = computeDailySeed();
        showToast("Daily challenge on");
      } else {
        showToast("Daily challenge off");
      }
      saveSettings();
      applySettingsToUI();
      // Return to mission hub to start a daily run.
      setStep(0);
      screenMissions.classList.remove("hidden");
      screenScenario.classList.add("hidden");
      screenSubmit.classList.add("hidden");
      screenSpellbook.classList.add("hidden");
      window.scrollTo({top:0, behavior:"smooth"});
    });

    if(btnSound) btnSound.addEventListener("click", async ()=>{
      await unlockAudio();
      STATE.soundOn = !STATE.soundOn;
      saveSettings();
      applySettingsToUI();
      playSfx("select");
      showToast(STATE.soundOn ? "Sound on" : "Sound off");
    });

    if(btnMotion) btnMotion.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      STATE.motionOn = !STATE.motionOn;
      saveSettings();
      applySettingsToUI();
      showToast(STATE.motionOn ? "Motion on" : "Motion off");
    });

    if(btnDifficulty) btnDifficulty.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      const order = ["normal","support","hard"];
      const i = Math.max(0, order.indexOf(STATE.difficulty));
      STATE.difficulty = order[(i + 1) % order.length];
      saveSettings();
      applySettingsToUI();
      showToast("Mode: " + (STATE.difficulty === "hard" ? "Hard" : (STATE.difficulty === "support" ? "Support" : "Normal")));
    });

    btnReset.addEventListener("click", resetAll);
    if(btnClearHistory) btnClearHistory.addEventListener("click", async ()=>{
      await unlockAudio();
      playSfx("select");
      setRunHistory([]);
      renderRunHistory();
      showToast("History cleared");
    });

    function resetAll(){
      STATE.step = 0;
      STATE.xp = 0;
      STATE.badges = [];
      STATE.artifacts = [];
      STATE.missionId = null;
      STATE.round = 0;
      STATE.decisionLog = [];
      STATE.savedJustifications = [];
      STATE.appliedSpells = [];
      STATE.runStartedAtMs = null;
      STATE.runEndedAtMs = null;
      STATE.streak = 0;
      STATE.runId = null;
      STATE.runSeed = null;
      STATE.runRank = null;
      STATE.timeTokens = 0;
      STATE.supportTokens = 0;
      STATE.streakShieldUsed = false;
      STATE.lensUsedRounds = [];
      STATE.runXpStart = 0;
      STATE.score = { base:0, theory:0, streak:0, spells:0, time:0 };
      VIEW_RUN = null;
      try{ localStorage.removeItem("biliteracyQuest_progress_v1"); } catch(_e){}
      stopRunTimer();
      setStep(0);
      updatePlayerPanel();
      renderMissions();
      updateLog();
      renderCanvasPostSafe();
      screenMissions.classList.remove("hidden");
      screenScenario.classList.add("hidden");
      screenSubmit.classList.add("hidden");
      screenSpellbook.classList.add("hidden");
      showToast("Reset");
      window.scrollTo({top:0, behavior:"smooth"});
    }

    function renderSpellbook(){
      spellbookEl.innerHTML = "";
      SPELLS.forEach(sp=>{
        const wrap = document.createElement("div");
        wrap.className = "spell";
        wrap.innerHTML = `
          <div class="spellTop">
            <div>
              <h4>${sp.title}</h4>
              <small>${sp.subtitle}</small>
            </div>
            <button type="button" class="miniBtn" data-open="${sp.id}">Open</button>
          </div>
          <div class="spellBody" id="body_${sp.id}">
            <p>${sp.body.join(" ")}</p>
            <ul>${sp.prompts.map(p=> `<li>${p}</li>`).join("")}</ul>
            <div class="spellActions">
              <button type="button" class="miniBtn miniBtnGold" data-apply="${sp.id}">Apply Spell</button>
              <button type="button" class="miniBtn" data-close="${sp.id}">Close</button>
            </div>
          </div>
        `;
        spellbookEl.appendChild(wrap);
      });

      spellbookEl.querySelectorAll("button[data-open]").forEach(b=>{
        b.addEventListener("click", ()=>{
          const id = b.getAttribute("data-open");
          el("body_" + id).style.display = "block";
        });
      });
      spellbookEl.querySelectorAll("button[data-close]").forEach(b=>{
        b.addEventListener("click", ()=>{
          const id = b.getAttribute("data-close");
          el("body_" + id).style.display = "none";
        });
      });
      spellbookEl.querySelectorAll("button[data-apply]").forEach(b=>{
        b.addEventListener("click", ()=>{
          const id = b.getAttribute("data-apply");
          const sp = SPELLS.find(s=> s.id === id);
          if(!sp) return;
          if(!STATE.appliedSpells.includes(sp.title)){
            if(STATE.supportTokens <= 0){
              playSfx("fail");
              showToast("Need a Support token to apply a spell");
              return;
            }
            STATE.supportTokens -= 1;
            STATE.appliedSpells.push(sp.title);
            addXP(20, "spells");
            playSfx("save");
            showToast("Spell applied");
            updateLog();
            renderCanvasPostSafe();
            updatePlayerPanel();
          } else {
            showToast("Already applied");
          }
        });
      });
    }

    // Checkpoint navigation (simple)
    questMap.querySelectorAll(".checkpoint").forEach(cp=>{
      cp.addEventListener("click", ()=>{
        const s = Number(cp.dataset.step);
        if(s === 0){
          screenMissions.classList.remove("hidden");
          screenScenario.classList.add("hidden");
          screenSubmit.classList.add("hidden");
          screenSpellbook.classList.add("hidden");
          setStep(0);
        }
        if(s === 2){
          screenSpellbook.classList.remove("hidden");
          screenMissions.classList.add("hidden");
          screenScenario.classList.add("hidden");
          screenSubmit.classList.add("hidden");
          renderSpellbook();
          setStep(2);
        }
        if(s === 4){
          if(STATE.missionId){
            if(!VIEW_RUN){
              VIEW_RUN = buildRunSnapshotFromState();
            }
            hydrateSubmitViewFromRun();
            screenSubmit.classList.remove("hidden");
            screenMissions.classList.add("hidden");
            screenScenario.classList.add("hidden");
            screenSpellbook.classList.add("hidden");
            setStep(4);
            renderCanvasPostSafe();
          } else {
            showToast("Finish a mission first");
          }
        }
      });
    });

    // Init
    STATE.dailySeed = computeDailySeed();
    loadSettings();
    loadProgress();
    renderMissions();
    setStep(0);
    updatePlayerPanel();
    updateLog();
    renderCanvasPostSafe();
  </script>
</body>
</html>
